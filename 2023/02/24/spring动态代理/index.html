<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Spring动态代理全解析 | pistachioss</title>
  <meta name="author" content="shineXGO">
  
  <meta name="description" content="Spring动态代理全解析：生成时机、源码脉络与代理类形态">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="Spring动态代理全解析"/>
  <meta property="og:site_name" content="pistachioss"/>

  
    <meta property="og:image" content=""/>
  

  
    <link rel="alternative" href="/atom.xml" title="pistachioss" type="application/atom+xml">
  
  
    <link href="/favicon.png" rel="icon">
  

  <!-- CSS -->
  <link rel="stylesheet" href="/css/themes/cerulean.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/font-awesome.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/responsive.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/highlight.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/highlight-default.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/google-fonts.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/comment.css" media="screen" type="text/css">
  <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/es5-shim/4.5.9/es5-shim.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/es5-shim/4.5.7/es5-sham.min.js"></script>
  <![endif]-->

  <script src="/js/jquery-2.0.3.min.js"></script>
  
  
	<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
	<script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
  
  <!-- analytics -->
  



<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <nav id="main-nav" class="navbar navbar-inverse navbar-default navbar-fixed-top" role="navigation">
    <div class="container">
      <button type="button" class="navbar-header navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
	<span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
       <a class="navbar-brand" href="/">pistachioss</a>
      <div class="collapse navbar-collapse nav-menu">
		<ul class="nav navbar-nav">
		  
		  <li>
			<a href="/archives" title="All the articles.">
			  <i class="fa fa-archive"></i>Archives
			</a>
		  </li>
		  
		  <li>
			<a href="/categories" title="All the categories.">
			  <i class="fa fa-folder"></i>Categories
			</a>
		  </li>
		  
		  <li>
			<a href="/tags" title="All the tags.">
			  <i class="fa fa-tags"></i>Tags
			</a>
		  </li>
		  
		  <li>
			<a href="/about" title="about me">
			  <i class="fa fa-user"></i>About
			</a>
		  </li>
		  
		</ul>
      </div>
    </div> <!-- container -->
</nav>
<div class="clearfix"></div>

  <div class="container">
    <div class="content">
      


	
		<div class="page-header page-header-inverse ">		
			<h1 class="title title-inverse "> Spring动态代理全解析</h1>
		</div>		
	






<div class="row post">
	<!-- cols -->
	
	<div id="top_meta"></div>
	<div class="col-md-9">
	

	<!-- content -->
	<div class="mypage">		
	  
		 <div class="alert alert-success description">
			<i class="fa fa-info-circle"></i> <p>Spring动态代理全解析：生成时机、源码脉络与代理类形态</p>
			
		 </div> <!-- alert -->
	  		

	  <h2 id="Spring动态代理全解析：生成时机、源码脉络与代理类形态"><a href="#Spring动态代理全解析：生成时机、源码脉络与代理类形态" class="headerlink" title="Spring动态代理全解析：生成时机、源码脉络与代理类形态"></a>Spring动态代理全解析：生成时机、源码脉络与代理类形态</h2><p>Spring框架的强大功能很大程度上依赖于其AOP（面向切面编程）机制，而动态代理则是AOP的核心实现方式。理解Spring何时以及如何为Bean生成代理，对于深入掌握Spring至关重要。</p>
<h3 id="一、代理类生成的时机：Bean生命周期中的关键节点"><a href="#一、代理类生成的时机：Bean生命周期中的关键节点" class="headerlink" title="一、代理类生成的时机：Bean生命周期中的关键节点"></a>一、代理类生成的时机：Bean生命周期中的关键节点</h3><p>Spring Bean的生命周期是一个复杂但有序的过程。代理类的生成通常发生在Bean<strong>初始化阶段之后</strong>的一个特定步骤。</p>
<p>核心的角色是 <code>BeanPostProcessor</code> 接口。这个接口允许我们在Bean的初始化前后插入自定义的逻辑。Spring AOP正是通过实现这个接口（具体来说是其子类，如 <code>AbstractAutoProxyCreator</code>）来在合适的时机创建代理对象的。</p>
<p><strong>关键时机点：<code>BeanPostProcessor</code>的<code>postProcessAfterInitialization</code>方法</strong></p>
<ol>
<li><strong>实例化 (Instantiation)</strong>：Spring根据Bean定义创建Bean的原始实例。</li>
<li><strong>属性填充 (Populate properties)</strong>：Spring为Bean实例注入依赖的属性。</li>
<li><strong>初始化 (Initialization)</strong>：<ul>
<li>执行各种Aware接口的回调（如 <code>BeanNameAware</code>, <code>BeanFactoryAware</code>）。</li>
<li>执行 <code>BeanPostProcessor</code> 的 <code>postProcessBeforeInitialization</code> 方法。</li>
<li>如果Bean实现了 <code>InitializingBean</code> 接口，执行其 <code>afterPropertiesSet()</code> 方法。</li>
<li>执行Bean定义中指定的自定义 <code>init-method</code>。</li>
<li><strong>执行 <code>BeanPostProcessor</code> 的 <code>postProcessAfterInitialization</code> 方法</strong>：<ul>
<li><strong>这是AOP代理创建的主要发生地</strong>。</li>
<li>Spring容器中注册的 <code>AbstractAutoProxyCreator</code>（例如处理 <code>@AspectJ</code> 注解的 <code>AnnotationAwareAspectJAutoProxyCreator</code>）会在这里检查当前的Bean是否需要被代理。</li>
<li>如果判断需要代理（比如该Bean的方法匹配了某个切点，或者Bean上有 <code>@Transactional</code> 等需要代理的注解），<code>AbstractAutoProxyCreator</code> 就会为原始Bean实例创建一个代理对象，并<strong>返回这个代理对象</strong>。</li>
<li>此时，Spring容器后续管理和注入的就不再是原始的Bean实例，而是这个代理实例了。</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>所以，简单来说，当一个普通的Bean经历完标准的实例化、属性填充和初始化方法（如<code>afterPropertiesSet</code>或自定义<code>init-method</code>）之后，Spring AOP的“代理检察官”（<code>BeanPostProcessor</code>）会介入，看看是否需要给这个刚“出炉”的Bean套上一层代理“外套”。如果需要，就生成并返回代理；如果不需要，就返回原始Bean。</p>
<h3 id="二、Bean加载与代理生成源码脉络（简化版）"><a href="#二、Bean加载与代理生成源码脉络（简化版）" class="headerlink" title="二、Bean加载与代理生成源码脉络（简化版）"></a>二、Bean加载与代理生成源码脉络（简化版）</h3><p>理解源码需要一定的耐心，我们尝试梳理一个简化的调用链，让你了解大致流程：</p>
<ol>
<li><strong>获取Bean的入口：<code>getBean()</code></strong><ul>
<li>当你调用 <code>ApplicationContext.getBean(&quot;someBean&quot;)</code> 时，最终会调用到 <code>AbstractBeanFactory</code> 的 <code>getBean()</code> 方法。</li>
</ul>
</li>
<li><strong>核心处理：<code>doGetBean()</code></strong><ul>
<li><code>AbstractBeanFactory.doGetBean()</code> 是获取Bean的核心逻辑。它会处理单例、原型等不同作用域的Bean。</li>
<li>对于单例Bean，它会先尝试从缓存（<code>singletonObjects</code>）中获取。如果获取不到，则进入创建流程。</li>
</ul>
</li>
<li><strong>创建Bean实例：<code>createBean()</code></strong><ul>
<li>如果Bean需要被创建，会调用 <code>AbstractAutowireCapableBeanFactory.createBean()</code>。</li>
</ul>
</li>
<li><strong>实际创建Bean：<code>doCreateBean()</code></strong><ul>
<li><code>AbstractAutowireCapableBeanFactory.doCreateBean()</code> 负责Bean的实例化（<code>createBeanInstance</code>）和属性填充（<code>populateBean</code>）。</li>
</ul>
</li>
<li><strong>初始化Bean：<code>initializeBean()</code></strong><ul>
<li>在Bean实例化和属性填充完毕后，会调用 <code>AbstractAutowireCapableBeanFactory.initializeBean()</code>。这个方法是初始化Bean的关键，也是代理可能产生的地方。</li>
<li><code>initializeBean()</code> 方法内部会依次调用：<ul>
<li><code>applyBeanPostProcessorsBeforeInitialization()</code>：执行所有 <code>BeanPostProcessor</code> 的 <code>postProcessBeforeInitialization</code> 方法。</li>
<li><code>invokeInitMethods()</code>：执行 <code>InitializingBean.afterPropertiesSet()</code> 和自定义的 <code>init-method</code>。</li>
<li><strong><code>applyBeanPostProcessorsAfterInitialization()</code></strong>：执行所有 <code>BeanPostProcessor</code> 的 <code>postProcessAfterInitialization</code> 方法。<strong>这是我们的主角登场的地方！</strong></li>
</ul>
</li>
</ul>
</li>
<li><strong>AOP代理的创建：<code>AbstractAutoProxyCreator.postProcessAfterInitialization()</code></strong><ul>
<li>在 <code>applyBeanPostProcessorsAfterInitialization()</code> 中，Spring会遍历所有注册的 <code>BeanPostProcessor</code>。</li>
<li>当轮到 <code>AbstractAutoProxyCreator</code>（或其子类，如 <code>AnnotationAwareAspectJAutoProxyCreator</code>）时，它的 <code>postProcessAfterInitialization(Object bean, String beanName)</code> 方法会被调用。</li>
<li>这个方法的核心逻辑是：<ul>
<li>判断当前 <code>bean</code> 是否已经被代理过，或者是否是基础设施类（不需要代理）。</li>
<li>调用 <code>wrapIfNecessary(bean, beanName, cacheKey)</code> 方法。</li>
</ul>
</li>
</ul>
</li>
<li><strong><code>wrapIfNecessary()</code>：决定是否及如何代理</strong><ul>
<li><code>AbstractAutoProxyCreator.wrapIfNecessary()</code> 方法是实际决定是否创建代理以及如何创建代理的地方。</li>
<li>它会收集所有适用于当前Bean的<strong>通知器 (Advisors)</strong>。Advisors封装了切面中的通知（Advice）和切点（Pointcut）。</li>
<li>如果找到了适用于该Bean的Advisors（意味着这个Bean需要被AOP增强），它就会调用 <code>createProxy()</code> 方法。</li>
</ul>
</li>
<li><strong><code>createProxy()</code>：使用ProxyFactory创建代理</strong><ul>
<li><code>AbstractAutoProxyCreator.createProxy()</code> 方法会：<ul>
<li>创建一个 <code>ProxyFactory</code> 实例。</li>
<li>将目标Bean（<code>targetSource</code>）、需要应用的Advisors、目标Bean实现的接口等信息设置到 <code>ProxyFactory</code> 中。</li>
<li><code>ProxyFactory</code> 会根据配置（目标类是否实现接口、<code>proxyTargetClass</code>属性等）决定使用JDK动态代理还是CGLIB代理。</li>
<li>调用 <code>proxyFactory.getProxy(getProxyClassLoader())</code> 来实际生成并返回代理对象。</li>
</ul>
</li>
</ul>
</li>
<li><strong>返回代理对象</strong><ul>
<li><code>AbstractAutoProxyCreator.postProcessAfterInitialization()</code> 方法最终会返回 <code>createProxy()</code> 生成的代理对象（如果需要代理的话），或者原始的 <code>bean</code> 对象（如果不需要代理）。</li>
<li>这个返回的对象（可能是原始对象，也可能是代理对象）会被放入Spring容器的单例缓存中，后续所有对该Bean的请求都会得到这个对象。</li>
</ul>
</li>
</ol>
<p><strong>简化流程总结：</strong></p>
<p><code>getBean()</code> -&gt; <code>doGetBean()</code> -&gt; (缓存未命中) -&gt; <code>createBean()</code> -&gt; <code>doCreateBean()</code> (实例化、属性填充) -&gt; <code>initializeBean()</code> -&gt; <code>applyBeanPostProcessorsAfterInitialization()</code> -&gt; <code>AbstractAutoProxyCreator.postProcessAfterInitialization()</code> -&gt; <code>wrapIfNecessary()</code> -&gt; (如果需要代理) -&gt; <code>createProxy()</code> (使用<code>ProxyFactory</code>) -&gt; 返回代理对象。</p>
<h3 id="三、生成的代理类是什么样子？"><a href="#三、生成的代理类是什么样子？" class="headerlink" title="三、生成的代理类是什么样子？"></a>三、生成的代理类是什么样子？</h3><p>Spring生成的代理类在运行时动态创建，我们无法直接看到它们的Java源码文件，但可以通过一些特征和工具（如Debug模式下的变量视图，或使用Java反编译工具分析内存中的类）来理解它们的结构。</p>
<h4 id="1-JDK动态代理生成的代理类"><a href="#1-JDK动态代理生成的代理类" class="headerlink" title="1. JDK动态代理生成的代理类"></a>1. JDK动态代理生成的代理类</h4><ul>
<li><strong>条件</strong>：当目标Bean<strong>实现了一个或多个接口</strong>，并且Spring没有被强制要求使用CGLIB时（即<code>proxyTargetClass</code>属性为<code>false</code>，这是默认情况）。</li>
<li><strong>特征</strong>：<ul>
<li><strong>命名规则</strong>：通常类名类似于 <code>com.sun.proxy.$ProxyX</code>，其中 <code>X</code> 是一个数字，如 <code>$Proxy0</code>, <code>$Proxy12</code>。</li>
<li><strong>实现接口</strong>：这个代理类会实现目标Bean所实现的所有接口，以及一些Spring内部的标记接口（如 <code>org.springframework.aop.SpringProxy</code>, <code>org.springframework.aop.framework.Advised</code>）。</li>
<li><strong>继承关系</strong>：它继承自 <code>java.lang.reflect.Proxy</code> 类。</li>
<li><strong>内部结构</strong>：<ul>
<li>它不包含目标Bean的原始业务逻辑代码。</li>
<li>它内部持有一个 <code>java.lang.reflect.InvocationHandler</code> 接口的实例。在Spring中，这个<code>InvocationHandler</code>的具体实现通常是 <code>org.springframework.aop.framework.JdkDynamicAopProxy</code>。</li>
<li>当代理对象的任何一个接口方法被调用时，这个调用会被转发到 <code>JdkDynamicAopProxy</code> 的 <code>invoke()</code> 方法。</li>
</ul>
</li>
<li><strong><code>JdkDynamicAopProxy.invoke()</code> 的工作</strong>：<ul>
<li>获取与当前方法匹配的所有AOP通知（Advisors&#x2F;Interceptors）。</li>
<li>构建一个调用链（Interceptor chain）。</li>
<li>依次执行调用链中的通知（例如，<code>@Before</code>通知 -&gt; 目标方法 -&gt; <code>@AfterReturning</code>通知）。</li>
<li>最终，如果需要，会通过反射调用原始目标Bean的对应方法。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>举例：</strong></p>
<p>假设我们有：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// 接口</span><br><span class="line">public interface UserService &#123;</span><br><span class="line">    void addUser(String username);</span><br><span class="line">    String getUser(String username);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 实现类</span><br><span class="line">public class UserServiceImpl implements UserService &#123;</span><br><span class="line">    public void addUser(String username) &#123;</span><br><span class="line">        System.out.println(&quot;UserServiceImpl: Adding user &quot; + username);</span><br><span class="line">    &#125;</span><br><span class="line">    public String getUser(String username) &#123;</span><br><span class="line">        System.out.println(&quot;UserServiceImpl: Getting user &quot; + username);</span><br><span class="line">        return &quot;User: &quot; + username;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 切面 (简单日志)</span><br><span class="line">@Aspect</span><br><span class="line">@Component</span><br><span class="line">public class LoggingAspect &#123;</span><br><span class="line">    @Before(&quot;execution(* com.example.UserService.addUser(..))&quot;)</span><br><span class="line">    public void logBeforeAddUser(JoinPoint joinPoint) &#123;</span><br><span class="line">        System.out.println(&quot;LoggingAspect: Before adding user - &quot; + joinPoint.getArgs()[0]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果Spring为 <code>UserServiceImpl</code> 生成JDK动态代理，这个代理类（假设叫 <code>$Proxy12</code>）在概念上会像这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">// 伪代码，实际是运行时生成的字节码</span><br><span class="line">public final class $Proxy12 extends java.lang.reflect.Proxy implements UserService, SpringProxy, Advised &#123;</span><br><span class="line">    private static Method m3; // addUser(String)</span><br><span class="line">    private static Method m4; // getUser(String)</span><br><span class="line">    // ... 其他接口的方法引用</span><br><span class="line"></span><br><span class="line">    // 构造函数，传入 InvocationHandler</span><br><span class="line">    public $Proxy12(InvocationHandler h) &#123;</span><br><span class="line">        super(h);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 实现UserService接口的方法</span><br><span class="line">    public final void addUser(String var1) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // this.h 就是 JdkDynamicAopProxy 实例</span><br><span class="line">            // 调用会被转发到 JdkDynamicAopProxy.invoke(this, m3, new Object[]&#123;var1&#125;)</span><br><span class="line">            this.h.invoke(this, m3, new Object[]&#123;var1&#125;);</span><br><span class="line">        &#125; catch (RuntimeException | Error e) &#123;</span><br><span class="line">            throw e;</span><br><span class="line">        &#125; catch (Throwable t) &#123;</span><br><span class="line">            throw new UndeclaredThrowableException(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public final String getUser(String var1) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            return (String) this.h.invoke(this, m4, new Object[]&#123;var1&#125;);</span><br><span class="line">        &#125; catch (RuntimeException | Error e) &#123;</span><br><span class="line">            throw e;</span><br><span class="line">        &#125; catch (Throwable t) &#123;</span><br><span class="line">            throw new UndeclaredThrowableException(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // ... 实现 SpringProxy, Advised 等接口的方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当你调用 <code>$Proxy12.addUser(&quot;test&quot;)</code> 时，实际上是调用了 <code>JdkDynamicAopProxy</code> 实例的 <code>invoke</code> 方法。这个 <code>invoke</code> 方法会先执行 <code>LoggingAspect</code> 中的 <code>logBeforeAddUser</code> 通知，然后再调用原始 <code>UserServiceImpl</code> 实例的 <code>addUser</code> 方法。</p>
<h4 id="2-CGLIB代理生成的代理类"><a href="#2-CGLIB代理生成的代理类" class="headerlink" title="2. CGLIB代理生成的代理类"></a>2. CGLIB代理生成的代理类</h4><ul>
<li><p><strong>条件</strong>：</p>
<ul>
<li>当目标Bean<strong>没有实现任何接口</strong>时。</li>
<li>或者，当Spring被明确配置为对类进行代理时（即<code>proxyTargetClass</code>属性设置为<code>true</code>）。</li>
</ul>
</li>
<li><p><strong>特征</strong>：</p>
<ul>
<li><p><strong>命名规则</strong>：类名通常是目标类的名称加上 </p>
<p>EnhancerBySpringCGLIB</p>
<p> 或类似的后缀，并附带一个哈希码，例如 <code>com.example.UserServiceImpl</code></p>
<p>EnhancerBySpringCGLIB</p>
<p><code>a1b2c3d4</code>。</p>
</li>
<li><p><strong>继承关系</strong>：这个代理类会<strong>继承</strong>目标Bean的类。因此，目标类不能是 <code>final</code> 的，需要被代理的方法也不能是 <code>final</code> 或 <code>private</code> 的。</p>
</li>
<li><p><strong>实现接口</strong>：它也会实现一些Spring内部的标记接口，如 <code>SpringProxy</code>, <code>Advised</code>。</p>
</li>
<li><p><strong>内部结构</strong>：</p>
<ul>
<li>它会重写目标类中所有公共的、受保护的非 <code>final</code> 方法。</li>
<li>在重写的方法内部，它不会直接包含原始业务逻辑，而是会委托给CGLIB的回调机制。</li>
<li>Spring会设置一个或多个CGLIB的 <code>MethodInterceptor</code>（通常是 <code>org.springframework.aop.framework.CglibAopProxy.DynamicAdvisedInterceptor</code>）作为回调。</li>
</ul>
</li>
<li><p><strong><code>DynamicAdvisedInterceptor.intercept()</code> 的工作</strong>：</p>
<ul>
<li>与JDK代理中的<code>invoke</code>方法类似，当代理对象的被重写方法被调用时，会触发 <code>DynamicAdvisedInterceptor</code> 的 <code>intercept()</code> 方法。</li>
<li>这个方法负责获取匹配的通知、构建调用链、执行通知，并最终调用原始目标Bean的对应方法（通过 <code>MethodProxy.invokeSuper()</code> 调用父类，即原始类的方法）。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>举例：</strong></p>
<p>如果 <code>UserServiceImpl</code> 没有实现 <code>UserService</code> 接口（或者 <code>proxyTargetClass=true</code>），Spring会为其生成CGLIB代理。这个代理类（假设叫 <code>UserServiceImpl</code></p>
<p>EnhancerBySpringCGLIB</p>
<p><code>a1b2c3d4</code>）在概念上会像这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">// 伪代码，实际是运行时生成的字节码</span><br><span class="line">public class UserServiceImpl$$EnhancerBySpringCGLIB$$a1b2c3d4 extends UserServiceImpl implements SpringProxy, Advised &#123;</span><br><span class="line">    private boolean CGLIB$BOUND;</span><br><span class="line">    public static Object CGLIB$FACTORY_DATA;</span><br><span class="line">    private static ThreadLocal CGLIB$THREAD_CALLBACKS;</span><br><span class="line">    private static Callback[] CGLIB$STATIC_CALLBACKS; // 其中一个就是 DynamicAdvisedInterceptor</span><br><span class="line">    // ... 其他CGLIB内部字段和方法</span><br><span class="line"></span><br><span class="line">    // 重写的 addUser 方法</span><br><span class="line">    public final void addUser(String var1) &#123;</span><br><span class="line">        // CGLIB$CALLBACK_0 就是我们关心的 DynamicAdvisedInterceptor</span><br><span class="line">        MethodInterceptor interceptor = CGLIB$CALLBACK_0;</span><br><span class="line">        if (interceptor == null) &#123;</span><br><span class="line">            // ... CGLIB内部初始化逻辑 ...</span><br><span class="line">            super.addUser(var1); // 如果没有拦截器，直接调用父类（原始类）方法</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        // 调用拦截器的 intercept 方法</span><br><span class="line">        // MethodProxy 用于高效调用父类（原始类）的同名方法</span><br><span class="line">        interceptor.intercept(this, /* addUser方法引用 */, new Object[]&#123;var1&#125;, /* MethodProxy */);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 重写的 getUser 方法</span><br><span class="line">    public final String getUser(String var1) &#123;</span><br><span class="line">        MethodInterceptor interceptor = CGLIB$CALLBACK_0;</span><br><span class="line">        if (interceptor == null) &#123;</span><br><span class="line">            return super.getUser(var1);</span><br><span class="line">        &#125;</span><br><span class="line">        return (String) interceptor.intercept(this, /* getUser方法引用 */, new Object[]&#123;var1&#125;, /* MethodProxy */);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // ... 其他被重写的方法和CGLIB的内部方法 ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当你调用 <code>UserServiceImpl</code></p>
<p>EnhancerBySpringCGLIB</p>
<p><code>a1b2c3d4.addUser(&quot;test&quot;)</code> 时，会执行到重写的 <code>addUser</code> 方法。这个方法会调用 <code>DynamicAdvisedInterceptor</code> 实例的 <code>intercept</code> 方法，该方法会执行AOP通知链，并最终通过 <code>MethodProxy</code> 调用原始 <code>UserServiceImpl</code>（即父类）的 <code>addUser</code> 方法。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><p><strong>代理生成时机</strong>：主要在Bean初始化完成后的 <code>BeanPostProcessor.postProcessAfterInitialization</code> 阶段，由 <code>AbstractAutoProxyCreator</code> 负责。</p>
</li>
<li><p><strong>源码关键</strong>：<code>getBean</code> -&gt; <code>initializeBean</code> -&gt; <code>applyBeanPostProcessorsAfterInitialization</code> -&gt; <code>AbstractAutoProxyCreator.wrapIfNecessary</code> -&gt; <code>ProxyFactory.getProxy</code>。</p>
</li>
<li><p><strong>代理类形态</strong>：</p>
<ul>
<li><p><strong>JDK动态代理</strong>：基于接口，生成实现接口的 <code>$ProxyX</code> 类，通过 <code>InvocationHandler</code> (如<code>JdkDynamicAopProxy</code>) 转发调用。</p>
</li>
<li><p><strong>CGLIB代理</strong>：基于继承，生成目标类的子类 <code>Target</code></p>
<p>EnhancerBySpringCGLIB</p>
<p><code>xxxx</code>，通过 <code>MethodInterceptor</code> (如<code>DynamicAdvisedInterceptor</code>) 拦截方法调用。</p>
</li>
</ul>
</li>
</ul>
<p>理解这些机制有助于你更深入地排查Spring AOP相关的问题，以及更好地利用Spring的声明式服务。</p>
	  
	</div>

	<!-- recommended posts -->
	

	<div>
  	<center>
	<div class="pagination">
<ul class="pagination">
	 
				
		<li class="prev"><a href="/2024/02/04/zgc/" class="alignleft prev"><i class="fa fa-arrow-circle-o-left"></i>Prev</a></li>
  		

        <li><a href="/archives"><i class="fa fa-archive"></i>Archive</a></li>

		
          <li class="next"><a href="/2022/06/08/spring-ioc/" class="alignright next">Next<i class="fa fa-arrow-circle-o-right"></i></a></li>
        
	
</ul>
</div>

    </center>
	</div>

    <!-- share -->
    
        
    <div class="bdsharebuttonbox">
        <a href="#" class="bds_more" data-cmd="more"></a>
        <a href="#" class="bds_weixin" data-cmd="weixin" title="分享到微信"></a>
        <a href="#" class="bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a>
        <a href="#" class="bds_fbook" data-cmd="fbook" title="分享到Facebook"></a>
        <a href="#" class="bds_twi" data-cmd="twi" title="分享到Twitter"></a>
        <a href="#" class="bds_linkedin" data-cmd="linkedin" title="分享到linkedin"></a>
        <a href="#" class="bds_evernotecn" data-cmd="evernotecn" title="分享到印象笔记"></a>
        <a href="#" class="bds_youdao" data-cmd="youdao" title="分享到有道云笔记"></a>
        <a href="#" class="bds_copy" data-cmd="copy" title="分享到复制网址"></a>
    </div>
    <script>
        window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"1","bdSize":"24"},"share":{}};
        with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
    </script>


        

    
	
	<!-- comment -->
	
<section id="comment">
  <h2 class="title">Comments</h2>
  
     <div id="gitalk-container"></div>
	 <script type="text/javascript">
	 // 拼接 body 内容
	    const decodedPageUrl = decodeURI(location.href)
		const issueBody = `${decodedPageUrl} \n\n Spring动态代理全解析：生成时机、源码脉络与代理类形态`;
        const gitalk = new Gitalk({
           clientID: 'Ov23liTbPXkD3NfIs0KX',
           clientSecret: '4e727600e55d74a25577449de551363030ee5a0e',
           repo: 'pistachioss.github.io',      // The repository of store comments,
           owner: 'pistachioss',
           admin: ['pistachioss'],
           id: decodeURI(location.pathname),      // Ensure uniqueness and length less than 50 
		   title: 'Spring动态代理全解析', // 使用文章标题作为 Issue 的标题
		   body: issueBody, // 拼接好的 body
		   distractionFreeMode: false  // Facebook-like distraction free mode
         });

         gitalk.render('gitalk-container');
	 </script>
  
</section>


	</div> <!-- col-md-9/col-md-12 -->
		
	
	<div id="side_meta">
		<div class="col-md-3" id="post_meta"> 

	<!-- date -->
	
	<div class="meta-widget">
	<i class="fa fa-clock-o"></i>
	2023-02-24 
	</div>
	

	<!-- categories -->
    
	<div class="meta-widget">
	<a data-toggle="collapse" data-target="#categorys"><i class="fa fa-folder"></i></a>	
    <ul id="categorys" class="tag_box list-unstyled collapse in">
          
  <li>
    <li><a href="/categories/Spring/">Spring<span>2</span></a></li> <li><a href="/categories/Spring/Java/">Java<span>1</span></a></li>
  </li>

    </ul>
	</div>
	

	<!-- tags -->
	
	<div class="meta-widget">
	<a data-toggle="collapse" data-target="#tags"><i class="fa fa-tags"></i></a>		  
    <ul id="tags" class="tag_box list-unstyled collapse in">	  
	    
  <li><a href="/tags/Aop/">Aop<span>1</span></a></li>

    </ul>
	</div>
	

	<!-- toc -->
	<div class="meta-widget">
	
	   <a data-toggle="collapse" data-target="#toc"><i class="fa fa-bars"></i></a>
	   <div id="toc" class="toc collapse in">
			<ol class="toc-article"><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#Spring%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%85%A8%E8%A7%A3%E6%9E%90%EF%BC%9A%E7%94%9F%E6%88%90%E6%97%B6%E6%9C%BA%E3%80%81%E6%BA%90%E7%A0%81%E8%84%89%E7%BB%9C%E4%B8%8E%E4%BB%A3%E7%90%86%E7%B1%BB%E5%BD%A2%E6%80%81"><span class="toc-article-text">Spring动态代理全解析：生成时机、源码脉络与代理类形态</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E4%B8%80%E3%80%81%E4%BB%A3%E7%90%86%E7%B1%BB%E7%94%9F%E6%88%90%E7%9A%84%E6%97%B6%E6%9C%BA%EF%BC%9ABean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%B8%AD%E7%9A%84%E5%85%B3%E9%94%AE%E8%8A%82%E7%82%B9"><span class="toc-article-text">一、代理类生成的时机：Bean生命周期中的关键节点</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E4%BA%8C%E3%80%81Bean%E5%8A%A0%E8%BD%BD%E4%B8%8E%E4%BB%A3%E7%90%86%E7%94%9F%E6%88%90%E6%BA%90%E7%A0%81%E8%84%89%E7%BB%9C%EF%BC%88%E7%AE%80%E5%8C%96%E7%89%88%EF%BC%89"><span class="toc-article-text">二、Bean加载与代理生成源码脉络（简化版）</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E4%B8%89%E3%80%81%E7%94%9F%E6%88%90%E7%9A%84%E4%BB%A3%E7%90%86%E7%B1%BB%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E5%AD%90%EF%BC%9F"><span class="toc-article-text">三、生成的代理类是什么样子？</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#1-JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%94%9F%E6%88%90%E7%9A%84%E4%BB%A3%E7%90%86%E7%B1%BB"><span class="toc-article-text">1. JDK动态代理生成的代理类</span></a></li><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#2-CGLIB%E4%BB%A3%E7%90%86%E7%94%9F%E6%88%90%E7%9A%84%E4%BB%A3%E7%90%86%E7%B1%BB"><span class="toc-article-text">2. CGLIB代理生成的代理类</span></a></li></ol></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-article-text">总结</span></a></li></ol></li></ol>
		</div>
	
	</div>
	
    <hr>
	
</div><!-- col-md-3 -->

	</div>
		

</div><!-- row -->




    </div>
  </div>
  <div class="container-narrow">
    <footer> <p>
  &copy; 2025 shineXGO
  
      with help from <a href="http://hexo.io/" target="_blank">Hexo</a> and <a href="http://getbootstrap.com/" target="_blank">Twitter Bootstrap</a>. Theme by <a target="_blank" rel="noopener" href="http://github.com/wzpan/hexo-theme-freemind/">Freemind</a>.    
</p> </footer>
  </div> <!-- container-narrow -->
  


  
<a id="gotop" href="#">   
  <span>▲</span> 
</a>

<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/bootstrap.min.js"></script>
<script src="/js/main.js"></script>
<script src="/js/search.js"></script> 


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>



   <script type="text/javascript">      
     var search_path = "search.xml";
	 if (search_path.length == 0) {
	 	search_path = "search.xml";
	 }
	 var path = "/" + search_path;
     searchFunc(path, 'local-search-input', 'local-search-result');
   </script>


<!-- syntax highlighting -->


</body>
</html>