<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>pistachioss</title>
  <meta name="author" content="shineXGO">
  
  <meta name="description" content="pistachioss delicious">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="pistachioss"/>

  
    <meta property="og:image" content=""/>
  

  
    <link rel="alternative" href="/atom.xml" title="pistachioss" type="application/atom+xml">
  
  
    <link href="/favicon.png" rel="icon">
  

  <!-- CSS -->
  <link rel="stylesheet" href="/css/themes/cerulean.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/font-awesome.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/responsive.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/highlight.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/highlight-default.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/google-fonts.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/comment.css" media="screen" type="text/css">
  <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/es5-shim/4.5.9/es5-shim.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/es5-shim/4.5.7/es5-sham.min.js"></script>
  <![endif]-->

  <script src="/js/jquery-2.0.3.min.js"></script>
  
  
	<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
	<script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
  
  <!-- analytics -->
  



<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <nav id="main-nav" class="navbar navbar-inverse navbar-default navbar-fixed-top" role="navigation">
    <div class="container">
      <button type="button" class="navbar-header navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
	<span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
       <a class="navbar-brand" href="/">pistachioss</a>
      <div class="collapse navbar-collapse nav-menu">
		<ul class="nav navbar-nav">
		  
		  <li>
			<a href="/archives" title="All the articles.">
			  <i class="fa fa-archive"></i>Archives
			</a>
		  </li>
		  
		  <li>
			<a href="/categories" title="All the categories.">
			  <i class="fa fa-folder"></i>Categories
			</a>
		  </li>
		  
		  <li>
			<a href="/tags" title="All the tags.">
			  <i class="fa fa-tags"></i>Tags
			</a>
		  </li>
		  
		  <li>
			<a href="/about" title="about me">
			  <i class="fa fa-user"></i>About
			</a>
		  </li>
		  
		  <li>
			<a href="/my-page-collection/" title="独立页面。">
			  <i class="fa fa-star"></i>Pages
			</a>
		  </li>
		  
		</ul>
      </div>
    </div> <!-- container -->
</nav>
<div class="clearfix"></div>

  <div class="container">
    <div class="content">
      <div class="page-header page-header-inverse ">
  <h1 class="title title-inverse ">zz</h1>
</div>

<div class="row page">

	
	<div class="col-md-9">
	

		
<div class="slogan">
      <i class="fa fa-heart"></i>
      Writing codes &amp; growing tao.
</div>


		<div id="top_search"></div>
		<div class="mypage">
		
		<!-- title and entry -->
        <!-- render top articles firstly -->
        
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
        
        <!-- render other articles -->
        
           
			  
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2025-05-13 </div>
			<div class="article-title"><a href="/2025/05/13/pdf2zn/" title="pdf翻译">nebius</a></div>
		</h3>
	


			  
<div class="entry">

  <div class="row">
	
	
		<h2 id="nebius"><a href="#nebius" class="headerlink" title="nebius"></a>nebius</h2><p><a target="_blank" rel="noopener" href="https://api.studio.nebius.ai/v1/chat/completions">https://api.studio.nebius.ai/v1/chat/completions</a></p>
<p>deepseek-ai&#x2F;DeepSeek-V3-0324</p>
<h2 id="prompt"><a href="#prompt" class="headerlink" title="prompt"></a>prompt</h2><p>您是一位专业的翻译助手，您的任务是将网页内容准确、自然、且富有感染力地翻译成目标语言。您尤其擅长捕捉原文的情感和语气，并将其自然地融入到译文中。<br>翻译请求指示:<br>您的输出必须仅包含译文本身，请勿包含任何前言、解释或其他非译文内容。<br>翻译要求 (请严格遵守):<br>语言风格: 地道的中文母语者日常口语风格，译文 自然流畅，避免书面语和机器翻译痕迹。<br>语气情感: 略微非正式的语气，充分传达原文用户的 热情和真诚的赞赏 之情。<br>表达技巧: 巧妙融入地道的中文俗语和口语化表达 (例如 “压榨”、“忍痛割爱” 等风格)，使译文生动活泼，贴近真实对话。<br>翻译策略: 避免生硬字面直译，理解原文核心意思和情感，用自然流畅中文 重新组织表达 (神形兼备)。<br>专有名词处理:对于英文原文中的 产品名称、软件名称、技术术语、模型名称、品牌名称、代码标识符或特定英文缩写等专有名词（例如 “Cursor”, “Gemini-2.5-pro-exp”, “VS Code”, “API”, “GPT-4”）， 必须保留其原始英文形式，不进行翻译。请将这些英文术语自然地嵌入到流畅的中文译文中。<br>译文目标: 高度自然地道的中文口语译文，如同真诚用户热情推荐，而非机器翻译。</p>
<p>请务必只返回高质量、地道的中文口语化译文！</p>
<h2 id="config"><a href="#config" class="headerlink" title="config"></a>config</h2><p><img src="/images%5Cimage-20250617083635531.png" alt="image-20250617083635531"></p>
<p><img src="/images%5Cimage-20250617083656827.png" alt="image-20250617083656827"></p>
<h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2>
	
	</div>
  <a type="button" href="/2025/05/13/pdf2zn/#more" class="btn btn-default more">Read More</a>
</div>

           
		
           
			  
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2025-03-11 </div>
			<div class="article-title"><a href="/2025/03/11/llm-agent-java/" title="基于springboot开发agent">llm-agent工具开发</a></div>
		</h3>
	


			  
<div class="entry">

  <div class="row">
	
	
		<p>开发一个基于 Spring Boot 和 Vue 的大模型 Agent，按照以下提示开发，最后你需要尽量去优化我没想到的地方，优化页面，让大模型Agent功能和市面上通用智能体差不多</p>
<h2 id="后端-Spring-Boot-编码提示词示例："><a href="#后端-Spring-Boot-编码提示词示例：" class="headerlink" title="后端 (Spring Boot) 编码提示词示例："></a>后端 (Spring Boot) 编码提示词示例：</h2><h3 id="建基础项目结构："><a href="#建基础项目结构：" class="headerlink" title="建基础项目结构："></a>建基础项目结构：</h3><ul>
<li>“为我生成一个 Spring Boot 3.x 项目的骨架，包含 Web, Lombok, Spring Data JPA (使用 H2 内存数据库作为示例) 和 Spring Security (基础认证) 的依赖。项目使用 Maven 管理，Java 版本为 17。”</li>
<li>“请为这个 Spring Boot 项目创建一个基础的目录结构，包括 controller, service, repository, model, config, dto 等包。”</li>
</ul>
<h3 id="义数据模型-Entity-DTO-："><a href="#义数据模型-Entity-DTO-：" class="headerlink" title="义数据模型 (Entity&#x2F;DTO)："></a>义数据模型 (Entity&#x2F;DTO)：</h3><ul>
<li>“为一个大模型 Agent 创建一个 Spring Boot JPA 实体类 <code>AgentTask</code>，它应该包含以下字段：<code>id</code> (Long, 主键, 自增), <code>taskName</code> (String, 非空), <code>prompt</code> (String, 文本类型), <code>status</code> (枚举类型 <code>TaskStatus</code>: PENDING, RUNNING, COMPLETED, FAILED), <code>createdAt</code> (LocalDateTime, 自动生成创建时间), <code>updatedAt</code> (LocalDateTime, 自动生成更新时间)。请同时生成相应的 Lombok注解 (<code>@Data</code>, <code>@Entity</code> 等)。”</li>
<li>“为 <code>AgentTask</code> 实体创建一个对应的 DTO 类 <code>AgentTaskDTO</code>，包含 <code>id</code>, <code>taskName</code>, <code>prompt</code>, <code>status</code> 字段。并为 <code>AgentTask</code> 和 <code>AgentTaskDTO</code> 之间编写一个 MapStruct 的映射接口。”</li>
</ul>
<h3 id="建-Repository-层："><a href="#建-Repository-层：" class="headerlink" title="建 Repository 层："></a>建 Repository 层：</h3><ul>
<li>“为 <code>AgentTask</code> 实体创建一个 Spring Data JPA Repository 接口 <code>AgentTaskRepository</code>，继承自 <code>JpaRepository</code>。并添加一个根据 <code>status</code> 查询任务列表的方法。”</li>
</ul>
	
	</div>
  <a type="button" href="/2025/03/11/llm-agent-java/#more" class="btn btn-default more">Read More</a>
</div>

           
		
           
			  
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2024-10-09 </div>
			<div class="article-title"><a href="/2024/10/09/prometheus-grafana/" title="Prometheus、Grafana ">Prometheus 数据类型解析与 Grafana 制图</a></div>
		</h3>
	


			  
<div class="entry">

  <div class="row">
	
	
		<p>阅读本文的前提是你分别知道 Grafana 和 Prometheus 是什么，要有一些最基本的了解。</p>
<p>本文会用一些比较接近实际情况的例子来帮助初学者理解 Prometheus 的数据类型，读完本文，你应该能充分了解 Prometheus 中主要数据类型的工作原理，以及能根据自己的需要使用合适的函数配置出相应的 Grafana 图表。</p>
<p>如果你没有环境进行实操，建议自己用 docker 搞一下，花点时间准备环境还是值得投入的。所以为了写本文，我提前写了一篇非常简单的文章，介绍如何搭建环境，大家可以参考。</p>
<h2 id="数据上报"><a href="#数据上报" class="headerlink" title="数据上报"></a>数据上报</h2><p>Prometheus 和一般的 APM 工具不一样，它采用的是由 server 端主动 pull 的交互模型，就是你准备好本地数据，然后在 Prometheus server 上配置好数据所在的地址，接下来就是等 Prometheus 来主动、定期拉取数据。</p>
<p>想要看到本地数据非常容易，对于 Spring Boot 应用来说，通常是访问 &#x2F;actuator&#x2F;prometheus 就可以了，当然不同的配置可能导致不同的地址，这里就不详述了。接口数据是纯文本的，采用 OpenMetrics 标准来组织内容。</p>
<p>内容类似如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># HELP executor_queued_tasks The approximate number <span class="keyword">of</span> tasks that <span class="keyword">are</span> queued <span class="keyword">for</span> execution</span><br><span class="line"># TYPE executor_queued_tasks gauge</span><br><span class="line">executor_queued_tasks&#123;name<span class="operator">=</span>&quot;applicationTaskExecutor&quot;&#125; <span class="number">0.0</span></span><br><span class="line"># HELP http_request_total  </span><br><span class="line"># TYPE http_request_total counter</span><br><span class="line">http_request_total&#123;application<span class="operator">=</span>&quot;order-service&quot;,ip<span class="operator">=</span>&quot;10.100.0.3&quot;,uri<span class="operator">=</span>&quot;/api/v1/order/crate&quot;&#125; <span class="number">2494624.0</span></span><br><span class="line">http_request_total&#123;application<span class="operator">=</span>&quot;order-service&quot;,ip<span class="operator">=</span>&quot;10.100.0.3&quot;,uri<span class="operator">=</span>&quot;/api/v1/order/query-detail&quot;&#125; <span class="number">2.1704952E7</span></span><br></pre></td></tr></table></figure>

<p># 开头的行主要描述这个指标是干啥的，以及定义它的数据类型，然后紧跟着时间序列以及它们当前的值。</p>
<blockquote>
<p>这个 OpenMetrics 标准最早就是 Prometheus 的内部数据格式规范，但是后来想把这个数据标准推广出来，让其他的 apm 工具可以直接使用，所以成立了一个项目单独发展，但是最新消息是，OpenMetrics 又合并回了 Prometheus 项目。</p>
</blockquote>
	
	</div>
  <a type="button" href="/2024/10/09/prometheus-grafana/#more" class="btn btn-default more">Read More</a>
</div>

           
		
           
			  
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2024-09-01 </div>
			<div class="article-title"><a href="/2024/09/01/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/" title="Sharding分库分表实践、主从读取">Sharding分库分表实践</a></div>
		</h3>
	


			  
<div class="entry">

  <div class="row">
	
	
		<p>好的，我们来详细讲解如何在 Spring Boot 项目中实战分库分表与读写分离。我们将选用业界广泛使用的 <strong>ShardingSphere</strong>（其 JDBC 驱动形式，即原 Sharding-JDBC）作为核心框架，因为它与 Spring Boot 集成良好，功能强大且社区活跃。</p>
<h2 id="目标场景"><a href="#目标场景" class="headerlink" title="目标场景:"></a><strong>目标场景:</strong></h2><ol>
<li><strong>分库 (Vertical&#x2F;Horizontal Sharding - Database Level):</strong> 将原来的单个 <code>order</code> 库拆分成两个物理库：<code>ds_0</code> 和 <code>ds_1</code>。<code>t_order</code> 和 <code>t_order_detail</code> 两张表的数据将根据某个规则（例如 <code>order_id</code> 或 <code>user_id</code>）分散到这两个库中。注意：这里不是垂直分库（一个库放 order，一个库放 detail），而是水平分库，每个库都有 <code>t_order</code> 和 <code>t_order_detail</code> 的一部分数据。</li>
<li><strong>分表 (Horizontal Sharding - Table Level):</strong> 在每个物理库 (<code>ds_0</code>, <code>ds_1</code>) 内部，<code>t_order</code> 表再分成两张物理表 <code>t_order_0</code>, <code>t_order_1</code>；<code>t_order_detail</code> 表也分成 <code>t_order_detail_0</code>, <code>t_order_detail_1</code>。分表规则通常也与 <code>order_id</code> 相关。</li>
<li><strong>读写分离 (Read&#x2F;Write Splitting):</strong> 为每个分片后的物理库（<code>ds_0</code>, <code>ds_1</code>）配置主从数据库。写入操作（INSERT, UPDATE, DELETE）路由到主库，读取操作（SELECT）路由到从库，以提高读取性能和可用性。</li>
<li><strong>绑定表 (Binding Tables):</strong> <code>t_order</code> 和 <code>t_order_detail</code> 是典型的关联表，它们应该始终位于同一个数据库分片和对应的表分片中（例如，<code>order_id</code> 为 100 的订单及其详情，如果 <code>t_order</code> 路由到 <code>ds_0.t_order_0</code>，那么 <code>t_order_detail</code> 也应该路由到 <code>ds_0.t_order_detail_0</code>）。ShardingSphere 支持配置绑定表来保证这一点。</li>
<li><strong>分布式主键:</strong> 使用 ShardingSphere 提供的 Snowflake 算法自动生成全局唯一的 <code>order_id</code>。</li>
</ol>
<h2 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型:**"></a>技术选型:**</h2><ul>
<li><strong>核心框架:</strong> Apache ShardingSphere (via <code>shardingsphere-jdbc-core-spring-boot-starter</code>)</li>
<li><strong>数据库:</strong> MySQL (演示需要至少 4 个实例：2 主 2 从)</li>
<li><strong>持久层:</strong> MyBatis (使用 <code>mybatis-spring-boot-starter</code>，JPA 也可以类似配置)</li>
<li><strong>构建工具:</strong> Maven</li>
<li><strong>开发环境:</strong> Spring Boot (e.g., 2.7.x or 3.x), Java 8+</li>
</ul>
<hr>
<h2 id="步骤详解"><a href="#步骤详解" class="headerlink" title="步骤详解:**"></a>步骤详解:**</h2><h3 id="第一步：环境准备与数据库设置"><a href="#第一步：环境准备与数据库设置" class="headerlink" title="第一步：环境准备与数据库设置**"></a>第一步：环境准备与数据库设置**</h3><ol>
<li><p><strong>安装 MySQL:</strong> 确保你有可用的 MySQL 服务。为了模拟读写分离和分库，你需要创建 4 个数据库实例（或在同一实例中创建 4 个 database）。我们假设：</p>
<ul>
<li><code>ds_0_master</code>: 主库 0 (写入 + 可能的读取)</li>
<li><code>ds_0_slave</code>: 从库 0 (只读)</li>
<li><code>ds_1_master</code>: 主库 1 (写入 + 可能的读取)</li>
<li><code>ds_1_slave</code>: 从库 1 (只读)</li>
</ul>
<p><em>注意:</em> 实际生产环境中，你需要配置 MySQL 的主从复制，确保 <code>ds_0_slave</code> 复制 <code>ds_0_master</code>，<code>ds_1_slave</code> 复制 <code>ds_1_master</code>。本示例代码不包含 MySQL 复制的配置，仅演示 ShardingSphere 如何连接和路由。</p>
</li>
<li><p><strong>创建数据库和表:</strong> 在对应的 MySQL 实例上执行以下 SQL。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 在 ds_0_master 和 ds_0_slave 上执行 (假设已创建好数据库 ds_0)</span></span><br><span class="line"><span class="comment">-- USE ds_0; -- 如果需要指定数据库</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE TABLE</span> `t_order_0` (</span><br><span class="line">  `order_id` <span class="type">bigint</span> <span class="keyword">NOT NULL</span>,</span><br><span class="line">  `user_id` <span class="type">int</span> <span class="keyword">NOT NULL</span>,</span><br><span class="line">  `order_no` <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `amount` <span class="type">decimal</span>(<span class="number">10</span>,<span class="number">2</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `create_time` datetime <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line">  <span class="keyword">PRIMARY KEY</span> (`order_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE TABLE</span> `t_order_1` (</span><br><span class="line">  `order_id` <span class="type">bigint</span> <span class="keyword">NOT NULL</span>,</span><br><span class="line">  `user_id` <span class="type">int</span> <span class="keyword">NOT NULL</span>,</span><br><span class="line">  `order_no` <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `amount` <span class="type">decimal</span>(<span class="number">10</span>,<span class="number">2</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `create_time` datetime <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line">  <span class="keyword">PRIMARY KEY</span> (`order_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE TABLE</span> `t_order_detail_0` (</span><br><span class="line">  `detail_id` <span class="type">bigint</span> <span class="keyword">NOT NULL</span> AUTO_INCREMENT, <span class="comment">-- 详情ID通常用自增，或也可用分布式ID</span></span><br><span class="line">  `order_id` <span class="type">bigint</span> <span class="keyword">NOT NULL</span>,</span><br><span class="line">  `item_name` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `quantity` <span class="type">int</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY KEY</span> (`detail_id`),</span><br><span class="line">  KEY `idx_order_id` (`order_id`) <span class="comment">-- 必须有 order_id 索引，用于关联查询和路由</span></span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE TABLE</span> `t_order_detail_1` (</span><br><span class="line">  `detail_id` <span class="type">bigint</span> <span class="keyword">NOT NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `order_id` <span class="type">bigint</span> <span class="keyword">NOT NULL</span>,</span><br><span class="line">  `item_name` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `quantity` <span class="type">int</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY KEY</span> (`detail_id`),</span><br><span class="line">  KEY `idx_order_id` (`order_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 在 ds_1_master 和 ds_1_slave 上执行 (假设已创建好数据库 ds_1)</span></span><br><span class="line"><span class="comment">-- USE ds_1; -- 如果需要指定数据库</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 重复上面的 CREATE TABLE 语句，创建 ds_1 库中的 t_order_0, t_order_1, t_order_detail_0, t_order_detail_1</span></span><br><span class="line"><span class="keyword">CREATE TABLE</span> `t_order_0` ( ... );</span><br><span class="line"><span class="keyword">CREATE TABLE</span> `t_order_1` ( ... );</span><br><span class="line"><span class="keyword">CREATE TABLE</span> `t_order_detail_0` ( ... );</span><br><span class="line"><span class="keyword">CREATE TABLE</span> `t_order_detail_1` ( ... );</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="第二步：创建-Spring-Boot-项目并添加依赖"><a href="#第二步：创建-Spring-Boot-项目并添加依赖" class="headerlink" title="第二步：创建 Spring Boot 项目并添加依赖**"></a>第二步：创建 Spring Boot 项目并添加依赖**</h2>
	
	</div>
  <a type="button" href="/2024/09/01/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/#more" class="btn btn-default more">Read More</a>
</div>

           
		
           
			  
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2024-06-08 </div>
			<div class="article-title"><a href="/2024/06/08/%E5%AD%97%E8%8A%82%E7%A0%81%E4%B9%A6%E7%B1%8D%E7%BA%BF%E8%B7%AF/" title="书籍推荐">字节码学习线路</a></div>
		</h3>
	


			  
<div class="entry">

  <div class="row">
	
	
		<h3 id="这是什么语言？"><a href="#这是什么语言？" class="headerlink" title="这是什么语言？"></a>这是什么语言？</h3><p>你看到的 <code>push ebp</code>, <code>mov ebp, esp</code> 等内容，属于 <strong>x86 汇编语言 (Assembly Language)</strong>。</p>
<ul>
<li><strong>汇编语言</strong>：它不是一种单一的语言，而是一族与特定计算机体系结构（CPU架构）紧密相关的低级编程语言。我们这里讨论的 x86 汇编，是为 Intel 和 AMD 等公司生产的 x86 架构 CPU 设计的“母语”。</li>
<li><strong>为什么是“低级”语言？</strong>：因为它与机器指令（CPU能直接执行的二进制代码）几乎是一一对应的。<code>mov</code>, <code>push</code>, <code>pop</code> 这些助记符，最终都会被翻译成特定的二进制数字（机器码）让CPU执行。</li>
<li><strong>与高级语言的关系</strong>：像 Java, C++, Python 这样的高级语言，最终都必须通过<strong>编译器 (Compiler)</strong> 或 <strong>解释器 (Interpreter) + 即时编译器 (JIT)</strong>，被翻译成汇编语言，然后再转成机器码，才能在CPU上运行。</li>
</ul>
<p>你之前问到的 JVM 锁升级、JIT 编译等，其最终在操作系统和硬件层面执行的，就是这些汇编指令。</p>
<hr>
<h3 id="需要学习什么书籍才能懂这些？"><a href="#需要学习什么书籍才能懂这些？" class="headerlink" title="需要学习什么书籍才能懂这些？"></a>需要学习什么书籍才能懂这些？</h3><p>懂了这些，就能真正理解“代码是如何运行的”。这需要一个系统性的学习路径，而不是只看一本书。推荐一个从基础到深入的学习路径和经典书籍。</p>
<h4 id="学习路径"><a href="#学习路径" class="headerlink" title="学习路径"></a>学习路径</h4><ol>
<li><strong>第一步：打好地基 —— 计算机组成原理 (Computer Organization)</strong><br>在学习汇编之前，你必须先知道计算机的基本构造：什么是CPU，什么是内存，什么是寄存器（EBP&#x2F;ESP就是寄存器），数据是如何在它们之间流动的。</li>
<li><strong>第二步：理解环境 —— 操作系统 (Operating Systems)</strong><br>程序不是在真空中运行的。操作系统负责管理进程、线程、内存（虚拟内存）、文件系统等。函数调用、栈的建立，都离不开操作系统的支持。</li>
<li><strong>第三步：学习语言本身 —— 汇编语言 (Assembly Language)</strong><br>掌握汇编指令、寻址模式、伪指令，并开始编写简单的汇编程序。</li>
<li><strong>第四步：连接高低 —— 编译原理 (Compilers)</strong><br>理解高级语言的结构（如 <code>if</code> 语句, <code>for</code> 循环, 函数调用）是如何被翻译成汇编语言的。这是将你已有的 Java&#x2F;C++ 知识与汇编知识连接起来的关键。</li>
</ol>
<h4 id="经典书籍推荐"><a href="#经典书籍推荐" class="headerlink" title="经典书籍推荐"></a>经典书籍推荐</h4>
	
	</div>
  <a type="button" href="/2024/06/08/%E5%AD%97%E8%8A%82%E7%A0%81%E4%B9%A6%E7%B1%8D%E7%BA%BF%E8%B7%AF/#more" class="btn btn-default more">Read More</a>
</div>

           
		
           
			  
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2024-02-04 </div>
			<div class="article-title"><a href="/2024/02/04/zgc/" title="ZGC">ZGC 介绍</a></div>
		</h3>
	


			  
<div class="entry">

  <div class="row">
	
	
		<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>ZGC 于 2017 由 Oracle 贡献给社区，在 JDK 11 及以上版本的各种 release 中几乎都包含该 GC。</p>
<p><a target="_blank" rel="noopener" href="https://wiki.openjdk.org/display/shenandoah/Main">Shenandoah</a> 是 Red Hat 主导的另一个低延迟的 GC，也承诺 pause time 低于 10ms，这两个项目目前处于竞争状态。该 GC 在 Oracle JDK 中不存在，但是在其他几个主流厂商的 JDK 中都包含，具体内容请参考项目主页。</p>
<h3 id="ZGC-的-“Z”-代表什么？"><a href="#ZGC-的-“Z”-代表什么？" class="headerlink" title="ZGC 的 “Z” 代表什么？"></a>ZGC 的 “Z” 代表什么？</h3><p>ZGC 只是一个名字，<strong>Z</strong> 不代表任何含义，不要把它理解为最后一代 GC，随着大家的探索，技术总是存在更优解。</p>
<p>It doesn’t stand for anything, ZGC is just a name. It was originally inspired by, or a homage to, ZFS (the filesystem) which in many ways was revolutionary when it first came out. Originally, ZFS was an acronym for “Zettabyte File System”, but that meaning was abandoned and it was later said to not stand for anything. It’s just a name. See <a target="_blank" rel="noopener" href="https://web.archive.org/web/20170223222515/https://blogs.oracle.com/bonwick/en_US/entry/you_say_zeta_i_say">Jeff Bonwick’s Blog</a> for more details.</p>
<h3 id="ZGC-的读法，”zed-gee-see”-or-“zee-gee-see”"><a href="#ZGC-的读法，”zed-gee-see”-or-“zee-gee-see”" class="headerlink" title="ZGC 的读法，”zed gee see” or “zee gee see”?"></a>ZGC 的读法，”zed gee see” or “zee gee see”?</h3><p>怎么读都行，无所谓。</p>
<p>There’s no preferred pronunciation, both are fine.</p>
<h2 id="ZGC-简单介绍"><a href="#ZGC-简单介绍" class="headerlink" title="ZGC 简单介绍"></a>ZGC 简单介绍</h2>
	
	</div>
  <a type="button" href="/2024/02/04/zgc/#more" class="btn btn-default more">Read More</a>
</div>

           
		
           
			  
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2023-02-24 </div>
			<div class="article-title"><a href="/2023/02/24/spring%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/" title="Spring动态代理全解析：生成时机、源码脉络与代理类形态">Spring动态代理全解析</a></div>
		</h3>
	


			  
<div class="entry">

  <div class="row">
	
	
		<h2 id="Spring动态代理全解析：生成时机、源码脉络与代理类形态"><a href="#Spring动态代理全解析：生成时机、源码脉络与代理类形态" class="headerlink" title="Spring动态代理全解析：生成时机、源码脉络与代理类形态"></a>Spring动态代理全解析：生成时机、源码脉络与代理类形态</h2><p>Spring框架的强大功能很大程度上依赖于其AOP（面向切面编程）机制，而动态代理则是AOP的核心实现方式。理解Spring何时以及如何为Bean生成代理，对于深入掌握Spring至关重要。</p>
<h3 id="一、代理类生成的时机：Bean生命周期中的关键节点"><a href="#一、代理类生成的时机：Bean生命周期中的关键节点" class="headerlink" title="一、代理类生成的时机：Bean生命周期中的关键节点"></a>一、代理类生成的时机：Bean生命周期中的关键节点</h3><p>Spring Bean的生命周期是一个复杂但有序的过程。代理类的生成通常发生在Bean<strong>初始化阶段之后</strong>的一个特定步骤。</p>
<p>核心的角色是 <code>BeanPostProcessor</code> 接口。这个接口允许我们在Bean的初始化前后插入自定义的逻辑。Spring AOP正是通过实现这个接口（具体来说是其子类，如 <code>AbstractAutoProxyCreator</code>）来在合适的时机创建代理对象的。</p>
<p><strong>关键时机点：<code>BeanPostProcessor</code>的<code>postProcessAfterInitialization</code>方法</strong></p>
<ol>
<li><strong>实例化 (Instantiation)</strong>：Spring根据Bean定义创建Bean的原始实例。</li>
<li><strong>属性填充 (Populate properties)</strong>：Spring为Bean实例注入依赖的属性。</li>
<li><strong>初始化 (Initialization)</strong>：<ul>
<li>执行各种Aware接口的回调（如 <code>BeanNameAware</code>, <code>BeanFactoryAware</code>）。</li>
<li>执行 <code>BeanPostProcessor</code> 的 <code>postProcessBeforeInitialization</code> 方法。</li>
<li>如果Bean实现了 <code>InitializingBean</code> 接口，执行其 <code>afterPropertiesSet()</code> 方法。</li>
<li>执行Bean定义中指定的自定义 <code>init-method</code>。</li>
<li><strong>执行 <code>BeanPostProcessor</code> 的 <code>postProcessAfterInitialization</code> 方法</strong>：<ul>
<li><strong>这是AOP代理创建的主要发生地</strong>。</li>
<li>Spring容器中注册的 <code>AbstractAutoProxyCreator</code>（例如处理 <code>@AspectJ</code> 注解的 <code>AnnotationAwareAspectJAutoProxyCreator</code>）会在这里检查当前的Bean是否需要被代理。</li>
<li>如果判断需要代理（比如该Bean的方法匹配了某个切点，或者Bean上有 <code>@Transactional</code> 等需要代理的注解），<code>AbstractAutoProxyCreator</code> 就会为原始Bean实例创建一个代理对象，并<strong>返回这个代理对象</strong>。</li>
<li>此时，Spring容器后续管理和注入的就不再是原始的Bean实例，而是这个代理实例了。</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>所以，简单来说，当一个普通的Bean经历完标准的实例化、属性填充和初始化方法（如<code>afterPropertiesSet</code>或自定义<code>init-method</code>）之后，Spring AOP的“代理检察官”（<code>BeanPostProcessor</code>）会介入，看看是否需要给这个刚“出炉”的Bean套上一层代理“外套”。如果需要，就生成并返回代理；如果不需要，就返回原始Bean。</p>
<h3 id="二、Bean加载与代理生成源码脉络（简化版）"><a href="#二、Bean加载与代理生成源码脉络（简化版）" class="headerlink" title="二、Bean加载与代理生成源码脉络（简化版）"></a>二、Bean加载与代理生成源码脉络（简化版）</h3><p>理解源码需要一定的耐心，我们尝试梳理一个简化的调用链，让你了解大致流程：</p>
	
	</div>
  <a type="button" href="/2023/02/24/spring%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/#more" class="btn btn-default more">Read More</a>
</div>

           
		
           
			  
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2022-06-08 </div>
			<div class="article-title"><a href="/2022/06/08/spring-ioc/" title="Spring启动">Spring IOC 容器源码分析</a></div>
		</h3>
	


			  
<div class="entry">

  <div class="row">
	
	
		<p>Spring 最重要的概念是 IOC 和 AOP，本篇文章其实就是要来分析下 Spring 的 IOC 容器。既然平时都要用到 Spring，怎么可以不好好了解 Spring 呢？阅读本文并不能让成为 Spring 专家，不过一定有助于理解 Spring 的很多概念，帮助排查应用中和 Spring 相关的一些问题。</p>
<p>本文采用的源码版本是 4.3.11.RELEASE，算是 5.0.x 前比较新的版本了。为了降低难度，本文所说的所有的内容都是基于 xml 的配置的方式，实际使用已经很少人这么做了，至少不是纯 xml 配置，不过从理解源码的角度来看用这种方式来说无疑是最合适的。</p>
<p>阅读建议：至少需要知道怎么配置 Spring，了解 Spring 中的各种概念，少部分内容假设我使用过 SpringMVC。本文要说的 IOC 总体来说有两处地方最重要，一个是创建 Bean 容器，一个是初始化 Bean，如果自己觉得一次性看完本文压力有点大，那么可以按这个思路分两次消化。不一定对 Spring 容器的源码感兴趣，也许附录部分介绍的知识对读者有些许作用。</p>
<p>希望通过本文可以让自己不惧怕阅读 Spring 源码，也希望能反馈表述错误或不合理的地方。</p>
<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>先看下最基本的启动 Spring 容器的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;classpath:applicationfile.xml&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码就可以利用配置文件来启动一个 Spring 容器了，请使用 maven 的小伙伴直接在 dependencies 中加上以下依赖即可，个人比较反对那些不知道要添加什么依赖，然后把 Spring 的所有相关的东西都加进来的方式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;spring-context&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;<span class="number">4.3</span><span class="number">.11</span>.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>spring-context 会自动将 spring-core、spring-beans、spring-aop、spring-expression 这几个基础 jar 包带进来。</p>
</blockquote>
	
	</div>
  <a type="button" href="/2022/06/08/spring-ioc/#more" class="btn btn-default more">Read More</a>
</div>

           
		
           
			  
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2022-03-04 </div>
			<div class="article-title"><a href="/2022/03/04/v2ray_x509_error/" title="Cloudflare v2ray一直 509 certificate signed by unknown authority">509 certificate signed by unknown authority</a></div>
		</h3>
	


			  
<div class="entry">

  <div class="row">
	
	
		<p>“x509: certificate signed by unknown authority” 错误表明 Nginx 或 V2Ray 客户端在验证 Cloudflare 源服务器证书（Origin Server Certificate）时，无法信任该证书的颁发机构（CA）。这通常是因为证书配置不正确、Cloudflare 的 SSL&#x2F;TLS 设置有误，或者缺少必要的根证书&#x2F;中间证书。本回答将针对你的 Cloudflare + V2Ray 配置（基于 WebSocket + TLS），提供详细的排查和解决步骤，帮助你修复这个错误。</p>
<h3 id="错误原因分析"><a href="#错误原因分析" class="headerlink" title="错误原因分析"></a><strong>错误原因分析</strong></h3><p>在 Cloudflare + V2Ray 的场景中，“certificate signed by unknown authority” 错误可能由以下原因引起：</p>
<ol>
<li><strong>源服务器证书未正确配置</strong>：Cloudflare 源服务器证书未正确安装到 Nginx，或文件内容有误。</li>
<li><strong>SSL&#x2F;TLS 模式问题</strong>：Cloudflare 的 SSL&#x2F;TLS 模式设置为 <strong>Full (strict)</strong>，但 VPS 未使用 Cloudflare 签发的证书，或者证书链不完整。</li>
<li><strong>缺少 Cloudflare 根证书</strong>：如果启用了 <strong>Authenticated Origin Pulls</strong>，Nginx 需要 Cloudflare 的根证书来验证边缘服务器的客户端证书。</li>
<li><strong>客户端配置错误</strong>：V2Ray 客户端的 TLS 设置（如 SNI）与服务器证书不匹配。</li>
<li><strong>证书和私钥不匹配</strong>：Nginx 使用的证书和私钥不对应，导致 TLS 握手失败。</li>
</ol>
<hr>
<h3 id="修复步骤"><a href="#修复步骤" class="headerlink" title="修复步骤"></a><strong>修复步骤</strong></h3><p>以下是针对 Cloudflare + V2Ray 配置的逐步排查和解决方法，假设你的 VPS 使用 Nginx 和 V2Ray，域名是 <code>v2ray.example.com</code>。</p>
<h4 id="步骤-1：检查-Nginx-错误日志"><a href="#步骤-1：检查-Nginx-错误日志" class="headerlink" title="步骤 1：检查 Nginx 错误日志"></a><strong>步骤 1：检查 Nginx 错误日志</strong></h4><ol>
<li>查看 Nginx 错误日志，获取详细错误信息：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /var/log/nginx/error.log</span><br></pre></td></tr></table></figure></li>
<li>查找类似以下的错误：<ul>
<li><code>x509: certificate signed by unknown authority</code></li>
<li><code>SSL: error:0B080074:x509 certificate routines</code></li>
</ul>
</li>
<li>记录具体错误上下文（例如错误发生在 TLS 握手还是客户端验证阶段）。</li>
</ol>
<h4 id="步骤-2：验证-Cloudflare-源服务器证书"><a href="#步骤-2：验证-Cloudflare-源服务器证书" class="headerlink" title="步骤 2：验证 Cloudflare 源服务器证书"></a><strong>步骤 2：验证 Cloudflare 源服务器证书</strong></h4>
	
	</div>
  <a type="button" href="/2022/03/04/v2ray_x509_error/#more" class="btn btn-default more">Read More</a>
</div>

           
		
           
			  
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2021-06-14 </div>
			<div class="article-title"><a href="/2021/06/14/Threads-And-Locks-md/" title="Threads-And-Locks">深入分析 java 8 编程语言规范：Threads and Locks</a></div>
		</h3>
	


			  
<div class="entry">

  <div class="row">
	
	
		<p>在 java 并发编程中，线程和锁永远是最重要的概念。语言规范虽然是规范描述，但是其中也有非常多的知识和最佳实践是值得学习的，相信这篇文章还是可以给很多读者提供学习参考的。</p>
<p>本文主要是<strong>翻译 + 解释</strong> Oracle《<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/index.html">The Java Language Specification, Java SE 8 Edition</a>》的第17章《<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-17.html">Threads and Locks</a>》，原文大概30页pdf，我加入了很多自己的理解，希望能帮大家把规范看懂，并且从中得到很多你一直想要知道但是还不知道的知识。</p>
<p>注意，本文在说 Java 语言规范，不是 JVM 规范，JVM 的实现需要满足语言规范中定义的内容，但是具体的实现细节由各 JVM 厂商自己来决定。所以，语言规范要尽可能严谨全面，但是也不能限制过多，不然会限制 JVM 厂商对很多细节进行性能优化。</p>
<p>我能力有限，虽然已经很用心了，但有些地方我真的不懂，我已经在文中标记出来了。</p>
<p>建议分 3 部分阅读。</p>
<ol>
<li>将 17.1、17.2、17.3 一起阅读，这里关于线程中的 wait、notify、中断有很多的知识；</li>
<li>17.4 的内存模型比较长，重排序和 happens-before 关系是重点；</li>
<li>剩下的 final、字分裂、double和long的非原子问题，这些都是相对独立的 topic。</li>
</ol>
<div style="text-align: center; font-size: 24px; font-weight: bold">Chapter 17. Threads and Locks</div>

<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在 java 中，线程由 Thread 类表示，用户创建线程的<strong>唯一方式</strong>是创建 Thread 类的一个实例，每一个线程都和这样的一个实例关联。在相应的 Thread 实例上调用 start() 方法将启动一个线程。</p>
<p>如果没有正确使用同步，线程表现出来的现象将会是令人疑惑的、违反直觉的。这个章节将描述多线程编程的语义问题，包括一系列的规则，这些规则定义了<strong>在多线程环境中线程对共享内存中值的修改是否对其他线程立即可见</strong>。java编程语言内存模型定义了统一的内存模型用于屏蔽不同的硬件架构，在没有歧义的情况下，下面将用<strong>内存模型</strong>表示这个概念。</p>
	
	</div>
  <a type="button" href="/2021/06/14/Threads-And-Locks-md/#more" class="btn btn-default more">Read More</a>
</div>

           
		

		</div>

		<!-- pagination -->
		<div>
  		<center>
		<div class="pagination">
<ul class="pagination">
	 
		
          <li class="prev disabled"><a><i class="fa fa-arrow-circle-o-left"></i>Prev</a></li>
        

        <li><a href="/"><i class="fa fa-home"></i>Home</a></li>

		
		   <li class="next"> <a href="/page/2/" class="alignright next">Next<i class="fa fa-arrow-circle-o-right"></i></a> </li>
        
	
</ul>
</div>

  		</center>
		</div>

		
		
	</div> <!-- col-md-9 -->

	
		<div class="col-md-3">
	<div id="sidebar">
	
			
  <div id="site_search">
   <div class="form-group">
    <input type="text" id="local-search-input" name="q" results="0" placeholder="Search" class="st-search-input st-default-search-input form-control"/>
   </div>  
  <div id="local-search-result"></div>
  </div>


		
			<div class="widget">
    
</div>

		
			
	<div class="widget">
		<h4>Categories</h4>
		<ul class="tag_box inline list-unstyled">
		
			<li><a href="/categories/Hexo/">Hexo<span>1</span></a></li>
		
			<li><a href="/categories/Java/">Java<span>3</span></a></li>
		
			<li><a href="/categories/Spring/Java/">Java<span>1</span></a></li>
		
			<li><a href="/categories/ShardingSphere/">ShardingSphere<span>1</span></a></li>
		
			<li><a href="/categories/Spring/">Spring<span>2</span></a></li>
		
			<li><a href="/categories/blog/">blog<span>1</span></a></li>
		
			<li><a href="/categories/v2ray/cloudflare/">cloudflare<span>1</span></a></li>
		
			<li><a href="/categories/%E4%BA%8B%E5%8A%A1/fat/">fat<span>1</span></a></li>
		
			<li><a href="/categories/llm/">llm<span>2</span></a></li>
		
			<li><a href="/categories/netty/">netty<span>1</span></a></li>
		
			<li><a href="/categories/llm/pdf/">pdf<span>1</span></a></li>
		
			<li><a href="/categories/v2ray/">v2ray<span>1</span></a></li>
		
			<li><a href="/categories/%E4%BA%8B%E5%8A%A1/">事务<span>1</span></a></li>
		
			<li><a href="/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程<span>10</span></a></li>
		
			<li><a href="/categories/%E7%9B%91%E6%8E%A7/">监控<span>1</span></a></li>
		
		</ul>
	</div>

		
			
	<div class="widget">
		<h4>Tag Cloud</h4>
		<ul class="tag_box inline list-unstyled">		
		
			<li><a href="/tags/pdf/">pdf<span>1</span></a></li>
		
			<li><a href="/tags/wiki/">wiki<span>22</span></a></li>
		
			<li><a href="/tags/llm/">llm<span>1</span></a></li>
		
			<li><a href="/tags/spring/">spring<span>1</span></a></li>
		
			<li><a href="/tags/aop/">aop<span>1</span></a></li>
		
		 
		</ul>
	</div>


		
			
<div class="widget">
  <h4>Recent Posts</h4>
  <ul class="entry list-unstyled">
    
      <li>
        <a href="/2025/05/13/pdf2zn/"  title="pdf翻译" ><i class="fa fa-file-o"></i>nebius</a>
      </li>
    
      <li>
        <a href="/2025/03/11/llm-agent-java/"  title="基于springboot开发agent" ><i class="fa fa-file-o"></i>llm-agent工具开发</a>
      </li>
    
      <li>
        <a href="/2024/10/09/prometheus-grafana/"  title="Prometheus、Grafana " ><i class="fa fa-file-o"></i>Prometheus 数据类型解析与 Grafana 制图</a>
      </li>
    
      <li>
        <a href="/2024/09/01/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/"  title="Sharding分库分表实践、主从读取" ><i class="fa fa-file-o"></i>Sharding分库分表实践</a>
      </li>
    
      <li>
        <a href="/2024/06/08/%E5%AD%97%E8%8A%82%E7%A0%81%E4%B9%A6%E7%B1%8D%E7%BA%BF%E8%B7%AF/"  title="书籍推荐" ><i class="fa fa-file-o"></i>字节码学习线路</a>
      </li>
    
  </ul>
</div>

		
	</div> <!-- sidebar -->
</div> <!-- col-md-3 -->

	

</div> <!-- row-fluid -->


    </div>
  </div>
  <div class="container-narrow">
    <footer> <p>
  &copy; 2025 shineXGO
  
      with help from <a href="http://hexo.io/" target="_blank">Hexo</a> and <a href="http://getbootstrap.com/" target="_blank">Twitter Bootstrap</a>. Theme by <a target="_blank" rel="noopener" href="http://github.com/wzpan/hexo-theme-freemind/">Freemind</a>.    
</p> </footer>
  </div> <!-- container-narrow -->
  


  
<a id="gotop" href="#">   
  <span>▲</span> 
</a>

<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/bootstrap.min.js"></script>
<script src="/js/main.js"></script>
<script src="/js/search.js"></script> 


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>



   <script type="text/javascript">      
     var search_path = "search.xml";
	 if (search_path.length == 0) {
	 	search_path = "search.xml";
	 }
	 var path = "/" + search_path;
     searchFunc(path, 'local-search-input', 'local-search-result');
   </script>


<!-- syntax highlighting -->


</body>
</html>