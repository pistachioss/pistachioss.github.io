---
title: tx-fat
date: 2021-06-14 11:12:11
categories: 
	- 事务
	- fat
tags: wiki
toc: true
description: "分布式事务框架"
---

## tx-fat 分布式事务框架面试介绍指南

面试官您好，我参与/负责的 `tx-fat` 项目是一个轻量级的分布式事务解决方案，主要目标是为微服务架构下的应用提供**最终一致性**的事务保障。

### 一、项目背景与痛点 (Why We Built It)

- **为什么需要这个项目？**
  - 在微服务架构下，一个完整的业务操作往往需要跨越多个独立部署的服务。传统的单体应用中的本地数据库事务（ACID）无法保证这种跨服务操作的原子性——要么所有服务的操作都成功，要么都失败。
  - **举个例子**：比如电商场景的下单操作，可能涉及到订单服务创建订单、库存服务扣减库存、积分服务增加积分。如果其中任何一个服务操作失败，我们希望整个下单流程都能回滚，避免数据不一致（比如订单创建了但库存没扣）。
  - 传统的强一致性分布式事务方案，比如基于 XA 协议的两阶段提交（2PC），虽然能保证强一致性，但通常**性能开销较大、实现复杂、对数据库和业务的侵入性也比较强**，在高并发的互联网场景下可能不太适用。
  - 因此，我们希望找到一种**更轻量、对业务侵入更小、性能表现更好**的解决方案，即使它牺牲了一点点的实时一致性，转而追求最终一致性。这就是我们开发 `tx-fat` 的初衷。

### 二、项目目标 (What We Aimed For)

- **我们想通过这个项目达到什么效果？**
  1. **易用性与低侵入性**：开发者可以通过简单的注解（比如 `@FatTransaction`）就能将普通方法接入分布式事务管理，而不需要修改大量的业务代码。
  2. **最终一致性保障**：在分布式环境下，保证参与事务的各个服务最终能够达到一致的状态，要么全部成功提交，要么全部成功回滚各自的操作。
  3. **主流RPC框架支持**：能够与业界主流的微服务通信框架（如 Dubbo、Spring Cloud OpenFeign）无缝集成，自动完成事务上下文的跨服务传播。
  4. **清晰的协调机制**：提供明确的事务提交和回滚协调流程，并通过外部协调服务（我们选择了Redis）来管理事务状态。
  5. **相对较好的性能**：相比传统的2PC方案，我们希望通过异步协调和优化的流程来获得更好的性能和吞吐量。

### 三、技术选型与核心架构 (How It Works - Overview)

- **项目的整体设计思路和用了哪些关键技术？**
  - **核心思想**：`tx-fat` 的核心思想借鉴了类似两阶段提交（2PC）的模式，但我们将其改造为一种**基于最终一致性的异步协调模型**。可以理解为，我们有一个“协调员”（事务发起者），它会先让所有“参与者”（其他微服务）尝试执行自己的那部分任务，并告诉协调员“我准备好了，可以提交”，或者“我出错了，大家一起回滚吧”。
  - **协调中心 - Redis**：
    - 我们选择 **Redis** 作为中心化的事务协调器和状态存储服务。
    - *为什么是Redis？* 因为 Redis 具备高性能的内存读写能力，支持丰富的数据结构（如 Set、List、String），并且可以方便地实现分布式锁、状态标记等原子操作，非常适合做这种轻量级的协调工作。
  - **事务管理与切入 - Spring AOP**：
    - 我们利用 **Spring AOP（面向切面编程）** 的能力，通过自定义注解（如 `@FatTransaction` 标记事务方法，`@FatServiceRegister` 注册服务的提交/回滚能力）来实现对事务的声明式管理。
    - 这意味着业务代码只需要关注业务逻辑，事务的开启、提交、回滚等横切关注点由框架通过AOP自动织入。
  - **事务上下文传播 - RPC拦截器/过滤器**：
    - 当一个服务调用链中包含多个微服务时，事务的相关信息（比如全局事务ID、当前分支ID等，我们称之为“事务上下文”）需要在这些服务间传递。
    - `tx-fat` 提供了对 Dubbo（通过 Filter）和 Spring Cloud OpenFeign（通过 RequestInterceptor 和 HandlerInterceptor）的集成，自动在RPC调用时传递这些上下文信息。
  - **一致性模型 - 最终一致性**：
    - 我们追求的是**最终一致性**。这意味着在事务执行过程中，系统可能会存在短暂的数据不一致状态（比如A服务成功了，B服务还在处理中）。但框架会努力确保，经过协调后，所有服务的数据最终会达到一致（要么都提交，要么都回滚到初始状态）。这通常涉及到**补偿逻辑**（即回滚操作）。

### 四、核心功能与实现细节 (How It Works - Key Details)

- **“能具体讲讲几个关键功能的实现吗？”** （这部分是面试官最可能深入追问的，你需要对代码细节有把握）
  1. **服务注册机制 (`@FatServiceRegister`, `ServiceRegisterAspect`)**：
     - “每个参与事务的服务都需要告诉框架，如果事务要提交，它应该执行哪个方法；如果事务要回滚，它又应该执行哪个补偿方法。这是怎么做到的？”
     - 开发者在服务实现类上使用 `@FatServiceRegister` 注解，指定服务名、提交方法名和回滚方法名。
     - 应用启动时，`ServiceRegisterAspect` 会扫描这些注解，并通过 `ServiceRegisterResolver` 将这些元数据（服务名 -> {提交方法, 回滚方法} 的映射）存储到 Redis 的一个特定 Key 中（比如 `SERVICE_SET:{serviceName}`）。这样，事务协调时就能动态查找到并调用它们。
  2. **事务的生命周期：发起、参与、协调**：
     - **事务发起 (`@FatTransaction`, `TransactionAspect`)**：
       - 当一个被 `@FatTransaction` 注解的方法首次被调用（或者注解显式指定 `isStart=true`），并且当前线程没有事务上下文时，它就成为**事务发起者**。
       - `TransactionAspect` 会拦截这个方法调用，生成一个全局唯一的事务组ID（`groupKey`）和当前分支ID（`currentKey`），并将这些信息封装在 `TransactionContent` 对象中，存入 `TransactionThreadLocal`，这样在同一个线程内就能共享这个事务信息。
       - 同时，发起者会将自己（服务名）注册到 Redis 的一个代表当前事务组的集合中（比如 `GROUP_SERVICE_SET:{groupKey}`），表明它参与了这个全局事务。
     - **事务参与 (RPC拦截与上下文传递)**：
       - 当发起者或其他已参与者通过RPC调用下游服务时，框架提供的RPC拦截器（如 `FatDubboFilter`）会从 `TransactionThreadLocal` 中获取 `TransactionContent`，将其序列化（通常是JSON），并附加到RPC请求中（比如Dubbo的Attachment或HTTP Header）。
       - 下游服务的RPC拦截器接收到请求后，会解析出这个事务上下文，并将其设置到自己线程的 `TransactionThreadLocal` 中。这样，下游服务就知道自己是某个全局事务的**参与者**了。它也会将自己的服务名注册到上述的 `GROUP_SERVICE_SET:{groupKey}`。
     - **事务提交协调 (`CommitResolver.commitTransaction()`)**：
       - “如果发起者的业务逻辑成功了，怎么确保所有参与者都一起提交呢？”
       - 发起者会调用 `CommitResolver`。这个协调器会做几件事：
         1. **检查全局回滚标记**：首先看 Redis 中是否有针对此 `groupKey` 的“一票否决”回滚标记（比如 `BLOCK_MARK:{groupKey}`）。如果有，说明已经有其他分支出错了，直接转入回滚。
         2. **等待所有参与者就绪**：发起者会等待（通过轮询 Redis 的特定 Key，比如 `SERVICE_READY_COMMIT_LIST:{groupKey}` 和 `GROUP_CAN_COMMIT_LIST:{groupKey}`，并设有超时机制）所有在 `GROUP_SERVICE_SET:{groupKey}` 中注册的参与者都声明自己“本地业务已完成，可以提交”。
         3. **执行最终提交**：如果所有参与者都确认可以提交，并且没有错误和超时，协调者就会通知所有参与者执行它们之前注册的 `commit` 方法（通过 `ServiceRunningHandler` 反射调用）。
         4. **清理状态**：提交完成后，清理 Redis 中与此事务相关的所有临时状态数据。
     - **事务回滚协调 (`CommitResolver.rollbackTransaction()`)**：
       - “如果任何一个环节出错了，如何保证所有操作都撤销呢？”
       - 回滚可能由多种情况触发：发起者业务异常、参与者业务异常（通过在 Redis 中设置错误标记 `SERVICE_ERROR_MARK:{groupKey}:{branchKey}` 被协调者发现）、提交或等待超时等。
       - 一旦决定回滚，协调者会：
         1. **设置全局回滚标记**：立即在 Redis 中设置 `BLOCK_MARK:{groupKey}`，阻止任何其他分支尝试提交。
         2. **执行补偿操作**：通知所有已参与的服务执行它们注册的 `rollback` 方法（补偿方法）。
         3. **清理状态**：回滚完成后，同样清理 Redis 中的事务状态数据。
  3. **Redis Key 的设计与运用**：
     - “你们在 Redis 中用了哪些关键的 Key 来管理事务状态？”
     - 可以重点介绍几个，比如：
       - `SERVICE_SET:{serviceName}`: 存储服务注册的提议/回滚方法。
       - `GROUP_SERVICE_SET:{groupKey}`: 记录参与当前事务的所有服务。
       - `BLOCK_MARK:{groupKey}`: 全局回滚标记。
       - `SERVICE_ERROR_MARK:{groupKey}:{branchKey}`: 特定分支错误标记。
       - `SERVICE_READY_COMMIT_LIST:{groupKey}` / `GROUP_CAN_COMMIT_LIST:{groupKey}`: 用于协调提交阶段各方状态的列表。
       - 并说明这些 Key 通常都会设置**过期时间（TTL）**，以防止异常情况下数据永久残留。

### 五、我的角色与贡献 (Your Role & Contribution)

- **“在这个项目中，你主要做了什么？”** （这部分需要根据你的实际情况来回答）

  - **如果你是核心设计者/开发者**：
    - “我是这个 `tx-fat` 框架的核心设计者和主要开发者之一。我负责了整体架构的设计，包括基于Redis的协调机制、AOP的事务切面逻辑、以及RPC上下文传播方案的选型与实现。”
    - “具体来说，我主导了 `CommitResolver` 模块的开发，确保了事务提交和回滚流程的可靠性。我还设计并实现了服务自动注册（`@FatServiceRegister` 相关）的功能。”
    - “在开发过程中，我对Redis Key的设计进行了多次迭代和优化，以平衡功能需求和性能开销。”
  - **如果你参与了特定模块的开发**：
    - “我在 `tx-fat` 项目中主要负责了对 Dubbo RPC框架的集成支持。具体工作包括编写 `FatDubboFilter` 来实现事务上下文的透传，以及相关的配置和测试工作。”
    - “我还参与了部分Redis操作逻辑的编码和单元测试，例如 `ServiceErrorOperation` 模块。”
  - **如果你对项目进行了优化或解决了关键问题**：
    - “在项目后期，我发现原有的事务状态轮询机制在高并发下对Redis压力较大，于是我参与设计并实现了一个优化的方案（可以说具体方案，比如结合Lua脚本减少网络IO，或者调整轮询策略等），将轮询频率降低了X%，Redis的CPU使用率下降了Y%。”
    - “我解决了一个关于并发场景下 `TransactionThreadLocal` 可能被错误清理导致事务上下文丢失的Bug。”

  *使用 **STAR 法则 (Situation, Task, Action, Result)** 来组织你的贡献会更清晰。*

### 六、项目成果与价值 (Value & Impact)

- **这个项目最终带来了什么好处？**
  - **业务层面**：成功解决了我们微服务体系中多个关键业务场景（例如：XX业务、YY业务）的跨服务数据一致性问题，显著降低了因数据不一致导致的业务故障率和客诉。
  - **开发层面**：为开发团队提供了一个简单易用的分布式事务解决方案，使得开发人员可以更专注于业务逻辑本身，而不用花费大量精力处理复杂的分布式一致性问题，从而**提高了开发效率，缩短了项目周期**。
  - **系统层面**：（如果可以量化）接入 `tx-fat` 后，相关业务接口的性能相比使用传统XA方案提升了X%（或者说，在可接受的最终一致性前提下，获得了比强一致性方案更好的吞吐量）。目前已有N个核心服务接入了该框架，稳定运行M个月。

### 七、挑战、反思与未来展望 (Challenges, Learnings & Future)

- **在做这个项目的过程中，遇到了哪些挑战？学到了什么？未来有什么可以改进的地方？**
  - **遇到的挑战**：
    - **保证Redis操作的原子性**：在复杂的协调流程中，很多时候需要对Redis的多个Key进行操作，如何保证这些操作的原子性是一个挑战。我们部分场景考虑了使用Redis事务（MULTI/EXEC）或Lua脚本。
    - **超时机制的设计**：如何设定合理的超时时间（包括RPC调用超时、Redis操作超时、整体事务超时）以避免资源被长时间锁定或无限等待，同时又不至于过于敏感导致正常事务失败，这需要反复调试和根据业务场景调整。
    - **网络分区与服务宕机**：如何尽可能优雅地处理这些分布式系统中的常见问题。`tx-fat` 主要依赖Redis的可用性和超时机制来发现问题，然后触发回滚。但更完善的方案可能需要更复杂的重试和故障恢复逻辑。
    - **补偿操作的幂等性**：回滚操作（补偿）如果因为网络问题被重复调用，需要保证其幂等性，即多次执行和一次执行的效果相同。这一点在设计服务的回滚接口时需要业务方特别注意，框架层面可以提供一些指导或辅助机制（`tx-fat` 可能未直接处理，但可以作为思考点提出）。
  - **学到的与反思**：
    - 深刻理解了CAP理论以及在实践中如何在CP和AP之间做权衡。`tx-fat`选择了最终一致性，是在可用性（A）和分区容错性（P）方面做了更多考量。
    - 对Spring AOP、RPC框架的内部机制有了更深入的理解。
    - 认识到设计一个健壮的分布式系统组件，需要考虑非常多的边界条件和异常情况。
    - **对比其他方案**：与Seata、LCN等成熟框架相比，`tx-fat` 更轻量，依赖更少，配置相对简单，适合中小型项目或对外部依赖有严格控制的场景。但可能在功能的全面性、自动化程度（如Seata AT模式的SQL解析和自动补偿）方面有所不足。
  - **未来展望**：
    - **引入消息队列**：可以考虑将事务的Confirm/Cancel阶段（即最终提交或回滚）通过可靠消息队列（如RocketMQ, Kafka）进行异步化处理，进一步提升主流程的性能和解耦。
    - **事务监控与告警**：增加对分布式事务执行情况的监控，比如事务耗时、成功率、异常事务列表等，并提供告警机制。
    - **更完善的容错与重试**：针对网络抖动、服务临时不可用等情况，引入更智能的重试策略。
    - **支持更多数据源和RPC框架**：扩展框架的适用范围。

**面试时的额外技巧：**

- **准备画图**：如果面试官要求，能快速在白板上画出核心架构图或关键流程图。
- **自信且诚实**：对于自己不清楚或项目中未涉及的部分，可以坦诚说明，并表达自己的学习意愿和思考方向。
- **突出思考过程**：不仅仅是描述做了什么，更要说明为什么这么做，对比过哪些方案，有哪些权衡。
- **结合具体场景**：用实际的业务例子来解释技术点，会更容易被理解。

希望这份指南能帮助你更好地准备面试！祝你成功！