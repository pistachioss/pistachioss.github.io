<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>wiki | pistachioss</title>
  <meta name="author" content="shineXGO">
  
  <meta name="description" content="pistachioss delicious">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="pistachioss"/>

  
    <meta property="og:image" content=""/>
  

  
    <link rel="alternative" href="/atom.xml" title="pistachioss" type="application/atom+xml">
  
  
    <link href="/favicon.png" rel="icon">
  

  <!-- CSS -->
  <link rel="stylesheet" href="/css/themes/cerulean.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/font-awesome.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/responsive.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/highlight.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/highlight-default.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/google-fonts.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/comment.css" media="screen" type="text/css">
  <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/es5-shim/4.5.9/es5-shim.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/es5-shim/4.5.7/es5-sham.min.js"></script>
  <![endif]-->

  <script src="/js/jquery-2.0.3.min.js"></script>
  
  
	<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
	<script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
  
  <!-- analytics -->
  



<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <nav id="main-nav" class="navbar navbar-inverse navbar-default navbar-fixed-top" role="navigation">
    <div class="container">
      <button type="button" class="navbar-header navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
	<span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
       <a class="navbar-brand" href="/">pistachioss</a>
      <div class="collapse navbar-collapse nav-menu">
		<ul class="nav navbar-nav">
		  
		  <li>
			<a href="/archives" title="All the articles.">
			  <i class="fa fa-archive"></i>Archives
			</a>
		  </li>
		  
		  <li>
			<a href="/categories" title="All the categories.">
			  <i class="fa fa-folder"></i>Categories
			</a>
		  </li>
		  
		  <li>
			<a href="/tags" title="All the tags.">
			  <i class="fa fa-tags"></i>Tags
			</a>
		  </li>
		  
		  <li>
			<a href="/about" title="about me">
			  <i class="fa fa-user"></i>About
			</a>
		  </li>
		  
		  <li>
			<a href="/my-page-collection/" title="独立页面。">
			  <i class="fa fa-star"></i>Pages
			</a>
		  </li>
		  
		</ul>
      </div>
    </div> <!-- container -->
</nav>
<div class="clearfix"></div>

  <div class="container">
    <div class="content">
      

<!-- title -->
<div class="page-header page-header-inverse ">
  <h1 class="archive-title-tag title title-inverse ">wiki</h1>
</div>

<div class="row page">
  <!-- cols -->
  
  <div class="col-md-9">
	

	  <div id="top_search"></div>

      
         <!-- display as entry -->
	     <div class="mypage">
	       
		     
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2025-03-11 </div>
			<div class="article-title"><a href="/2025/03/11/llm-agent-java/" title="基于springboot开发agent">llm-agent工具开发</a></div>
		</h3>
	


		     
<div class="entry">

  <div class="row">
	
	
		<p>开发一个基于 Spring Boot 和 Vue 的大模型 Agent，按照以下提示开发，最后你需要尽量去优化我没想到的地方，优化页面，让大模型Agent功能和市面上通用智能体差不多</p>
<h2 id="后端-Spring-Boot-编码提示词示例："><a href="#后端-Spring-Boot-编码提示词示例：" class="headerlink" title="后端 (Spring Boot) 编码提示词示例："></a>后端 (Spring Boot) 编码提示词示例：</h2><h3 id="建基础项目结构："><a href="#建基础项目结构：" class="headerlink" title="建基础项目结构："></a>建基础项目结构：</h3><ul>
<li>“为我生成一个 Spring Boot 3.x 项目的骨架，包含 Web, Lombok, Spring Data JPA (使用 H2 内存数据库作为示例) 和 Spring Security (基础认证) 的依赖。项目使用 Maven 管理，Java 版本为 17。”</li>
<li>“请为这个 Spring Boot 项目创建一个基础的目录结构，包括 controller, service, repository, model, config, dto 等包。”</li>
</ul>
<h3 id="义数据模型-Entity-DTO-："><a href="#义数据模型-Entity-DTO-：" class="headerlink" title="义数据模型 (Entity&#x2F;DTO)："></a>义数据模型 (Entity&#x2F;DTO)：</h3><ul>
<li>“为一个大模型 Agent 创建一个 Spring Boot JPA 实体类 <code>AgentTask</code>，它应该包含以下字段：<code>id</code> (Long, 主键, 自增), <code>taskName</code> (String, 非空), <code>prompt</code> (String, 文本类型), <code>status</code> (枚举类型 <code>TaskStatus</code>: PENDING, RUNNING, COMPLETED, FAILED), <code>createdAt</code> (LocalDateTime, 自动生成创建时间), <code>updatedAt</code> (LocalDateTime, 自动生成更新时间)。请同时生成相应的 Lombok注解 (<code>@Data</code>, <code>@Entity</code> 等)。”</li>
<li>“为 <code>AgentTask</code> 实体创建一个对应的 DTO 类 <code>AgentTaskDTO</code>，包含 <code>id</code>, <code>taskName</code>, <code>prompt</code>, <code>status</code> 字段。并为 <code>AgentTask</code> 和 <code>AgentTaskDTO</code> 之间编写一个 MapStruct 的映射接口。”</li>
</ul>
<h3 id="建-Repository-层："><a href="#建-Repository-层：" class="headerlink" title="建 Repository 层："></a>建 Repository 层：</h3><ul>
<li>“为 <code>AgentTask</code> 实体创建一个 Spring Data JPA Repository 接口 <code>AgentTaskRepository</code>，继承自 <code>JpaRepository</code>。并添加一个根据 <code>status</code> 查询任务列表的方法。”</li>
</ul>
	
	</div>
  <a type="button" href="/2025/03/11/llm-agent-java/#more" class="btn btn-default more">Read More</a>
</div>

	       
		     
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2024-10-09 </div>
			<div class="article-title"><a href="/2024/10/09/prometheus-grafana/" title="Prometheus、Grafana ">Prometheus 数据类型解析与 Grafana 制图</a></div>
		</h3>
	


		     
<div class="entry">

  <div class="row">
	
	
		<p>阅读本文的前提是你分别知道 Grafana 和 Prometheus 是什么，要有一些最基本的了解。</p>
<p>本文会用一些比较接近实际情况的例子来帮助初学者理解 Prometheus 的数据类型，读完本文，你应该能充分了解 Prometheus 中主要数据类型的工作原理，以及能根据自己的需要使用合适的函数配置出相应的 Grafana 图表。</p>
<p>如果你没有环境进行实操，建议自己用 docker 搞一下，花点时间准备环境还是值得投入的。所以为了写本文，我提前写了一篇非常简单的文章，介绍如何搭建环境，大家可以参考。</p>
<h2 id="数据上报"><a href="#数据上报" class="headerlink" title="数据上报"></a>数据上报</h2><p>Prometheus 和一般的 APM 工具不一样，它采用的是由 server 端主动 pull 的交互模型，就是你准备好本地数据，然后在 Prometheus server 上配置好数据所在的地址，接下来就是等 Prometheus 来主动、定期拉取数据。</p>
<p>想要看到本地数据非常容易，对于 Spring Boot 应用来说，通常是访问 &#x2F;actuator&#x2F;prometheus 就可以了，当然不同的配置可能导致不同的地址，这里就不详述了。接口数据是纯文本的，采用 OpenMetrics 标准来组织内容。</p>
<p>内容类似如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># HELP executor_queued_tasks The approximate number <span class="keyword">of</span> tasks that <span class="keyword">are</span> queued <span class="keyword">for</span> execution</span><br><span class="line"># TYPE executor_queued_tasks gauge</span><br><span class="line">executor_queued_tasks&#123;name<span class="operator">=</span>&quot;applicationTaskExecutor&quot;&#125; <span class="number">0.0</span></span><br><span class="line"># HELP http_request_total  </span><br><span class="line"># TYPE http_request_total counter</span><br><span class="line">http_request_total&#123;application<span class="operator">=</span>&quot;order-service&quot;,ip<span class="operator">=</span>&quot;10.100.0.3&quot;,uri<span class="operator">=</span>&quot;/api/v1/order/crate&quot;&#125; <span class="number">2494624.0</span></span><br><span class="line">http_request_total&#123;application<span class="operator">=</span>&quot;order-service&quot;,ip<span class="operator">=</span>&quot;10.100.0.3&quot;,uri<span class="operator">=</span>&quot;/api/v1/order/query-detail&quot;&#125; <span class="number">2.1704952E7</span></span><br></pre></td></tr></table></figure>

<p># 开头的行主要描述这个指标是干啥的，以及定义它的数据类型，然后紧跟着时间序列以及它们当前的值。</p>
<blockquote>
<p>这个 OpenMetrics 标准最早就是 Prometheus 的内部数据格式规范，但是后来想把这个数据标准推广出来，让其他的 apm 工具可以直接使用，所以成立了一个项目单独发展，但是最新消息是，OpenMetrics 又合并回了 Prometheus 项目。</p>
</blockquote>
	
	</div>
  <a type="button" href="/2024/10/09/prometheus-grafana/#more" class="btn btn-default more">Read More</a>
</div>

	       
		     
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2024-09-01 </div>
			<div class="article-title"><a href="/2024/09/01/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/" title="Sharding分库分表实践、主从读取">Sharding分库分表实践</a></div>
		</h3>
	


		     
<div class="entry">

  <div class="row">
	
	
		<p>好的，我们来详细讲解如何在 Spring Boot 项目中实战分库分表与读写分离。我们将选用业界广泛使用的 <strong>ShardingSphere</strong>（其 JDBC 驱动形式，即原 Sharding-JDBC）作为核心框架，因为它与 Spring Boot 集成良好，功能强大且社区活跃。</p>
<h2 id="目标场景"><a href="#目标场景" class="headerlink" title="目标场景:"></a><strong>目标场景:</strong></h2><ol>
<li><strong>分库 (Vertical&#x2F;Horizontal Sharding - Database Level):</strong> 将原来的单个 <code>order</code> 库拆分成两个物理库：<code>ds_0</code> 和 <code>ds_1</code>。<code>t_order</code> 和 <code>t_order_detail</code> 两张表的数据将根据某个规则（例如 <code>order_id</code> 或 <code>user_id</code>）分散到这两个库中。注意：这里不是垂直分库（一个库放 order，一个库放 detail），而是水平分库，每个库都有 <code>t_order</code> 和 <code>t_order_detail</code> 的一部分数据。</li>
<li><strong>分表 (Horizontal Sharding - Table Level):</strong> 在每个物理库 (<code>ds_0</code>, <code>ds_1</code>) 内部，<code>t_order</code> 表再分成两张物理表 <code>t_order_0</code>, <code>t_order_1</code>；<code>t_order_detail</code> 表也分成 <code>t_order_detail_0</code>, <code>t_order_detail_1</code>。分表规则通常也与 <code>order_id</code> 相关。</li>
<li><strong>读写分离 (Read&#x2F;Write Splitting):</strong> 为每个分片后的物理库（<code>ds_0</code>, <code>ds_1</code>）配置主从数据库。写入操作（INSERT, UPDATE, DELETE）路由到主库，读取操作（SELECT）路由到从库，以提高读取性能和可用性。</li>
<li><strong>绑定表 (Binding Tables):</strong> <code>t_order</code> 和 <code>t_order_detail</code> 是典型的关联表，它们应该始终位于同一个数据库分片和对应的表分片中（例如，<code>order_id</code> 为 100 的订单及其详情，如果 <code>t_order</code> 路由到 <code>ds_0.t_order_0</code>，那么 <code>t_order_detail</code> 也应该路由到 <code>ds_0.t_order_detail_0</code>）。ShardingSphere 支持配置绑定表来保证这一点。</li>
<li><strong>分布式主键:</strong> 使用 ShardingSphere 提供的 Snowflake 算法自动生成全局唯一的 <code>order_id</code>。</li>
</ol>
<h2 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型:**"></a>技术选型:**</h2><ul>
<li><strong>核心框架:</strong> Apache ShardingSphere (via <code>shardingsphere-jdbc-core-spring-boot-starter</code>)</li>
<li><strong>数据库:</strong> MySQL (演示需要至少 4 个实例：2 主 2 从)</li>
<li><strong>持久层:</strong> MyBatis (使用 <code>mybatis-spring-boot-starter</code>，JPA 也可以类似配置)</li>
<li><strong>构建工具:</strong> Maven</li>
<li><strong>开发环境:</strong> Spring Boot (e.g., 2.7.x or 3.x), Java 8+</li>
</ul>
<hr>
<h2 id="步骤详解"><a href="#步骤详解" class="headerlink" title="步骤详解:**"></a>步骤详解:**</h2><h3 id="第一步：环境准备与数据库设置"><a href="#第一步：环境准备与数据库设置" class="headerlink" title="第一步：环境准备与数据库设置**"></a>第一步：环境准备与数据库设置**</h3><ol>
<li><p><strong>安装 MySQL:</strong> 确保你有可用的 MySQL 服务。为了模拟读写分离和分库，你需要创建 4 个数据库实例（或在同一实例中创建 4 个 database）。我们假设：</p>
<ul>
<li><code>ds_0_master</code>: 主库 0 (写入 + 可能的读取)</li>
<li><code>ds_0_slave</code>: 从库 0 (只读)</li>
<li><code>ds_1_master</code>: 主库 1 (写入 + 可能的读取)</li>
<li><code>ds_1_slave</code>: 从库 1 (只读)</li>
</ul>
<p><em>注意:</em> 实际生产环境中，你需要配置 MySQL 的主从复制，确保 <code>ds_0_slave</code> 复制 <code>ds_0_master</code>，<code>ds_1_slave</code> 复制 <code>ds_1_master</code>。本示例代码不包含 MySQL 复制的配置，仅演示 ShardingSphere 如何连接和路由。</p>
</li>
<li><p><strong>创建数据库和表:</strong> 在对应的 MySQL 实例上执行以下 SQL。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 在 ds_0_master 和 ds_0_slave 上执行 (假设已创建好数据库 ds_0)</span></span><br><span class="line"><span class="comment">-- USE ds_0; -- 如果需要指定数据库</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE TABLE</span> `t_order_0` (</span><br><span class="line">  `order_id` <span class="type">bigint</span> <span class="keyword">NOT NULL</span>,</span><br><span class="line">  `user_id` <span class="type">int</span> <span class="keyword">NOT NULL</span>,</span><br><span class="line">  `order_no` <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `amount` <span class="type">decimal</span>(<span class="number">10</span>,<span class="number">2</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `create_time` datetime <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line">  <span class="keyword">PRIMARY KEY</span> (`order_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE TABLE</span> `t_order_1` (</span><br><span class="line">  `order_id` <span class="type">bigint</span> <span class="keyword">NOT NULL</span>,</span><br><span class="line">  `user_id` <span class="type">int</span> <span class="keyword">NOT NULL</span>,</span><br><span class="line">  `order_no` <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `amount` <span class="type">decimal</span>(<span class="number">10</span>,<span class="number">2</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `create_time` datetime <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line">  <span class="keyword">PRIMARY KEY</span> (`order_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE TABLE</span> `t_order_detail_0` (</span><br><span class="line">  `detail_id` <span class="type">bigint</span> <span class="keyword">NOT NULL</span> AUTO_INCREMENT, <span class="comment">-- 详情ID通常用自增，或也可用分布式ID</span></span><br><span class="line">  `order_id` <span class="type">bigint</span> <span class="keyword">NOT NULL</span>,</span><br><span class="line">  `item_name` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `quantity` <span class="type">int</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY KEY</span> (`detail_id`),</span><br><span class="line">  KEY `idx_order_id` (`order_id`) <span class="comment">-- 必须有 order_id 索引，用于关联查询和路由</span></span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE TABLE</span> `t_order_detail_1` (</span><br><span class="line">  `detail_id` <span class="type">bigint</span> <span class="keyword">NOT NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `order_id` <span class="type">bigint</span> <span class="keyword">NOT NULL</span>,</span><br><span class="line">  `item_name` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `quantity` <span class="type">int</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY KEY</span> (`detail_id`),</span><br><span class="line">  KEY `idx_order_id` (`order_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 在 ds_1_master 和 ds_1_slave 上执行 (假设已创建好数据库 ds_1)</span></span><br><span class="line"><span class="comment">-- USE ds_1; -- 如果需要指定数据库</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 重复上面的 CREATE TABLE 语句，创建 ds_1 库中的 t_order_0, t_order_1, t_order_detail_0, t_order_detail_1</span></span><br><span class="line"><span class="keyword">CREATE TABLE</span> `t_order_0` ( ... );</span><br><span class="line"><span class="keyword">CREATE TABLE</span> `t_order_1` ( ... );</span><br><span class="line"><span class="keyword">CREATE TABLE</span> `t_order_detail_0` ( ... );</span><br><span class="line"><span class="keyword">CREATE TABLE</span> `t_order_detail_1` ( ... );</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="第二步：创建-Spring-Boot-项目并添加依赖"><a href="#第二步：创建-Spring-Boot-项目并添加依赖" class="headerlink" title="第二步：创建 Spring Boot 项目并添加依赖**"></a>第二步：创建 Spring Boot 项目并添加依赖**</h2>
	
	</div>
  <a type="button" href="/2024/09/01/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/#more" class="btn btn-default more">Read More</a>
</div>

	       
		     
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2024-06-08 </div>
			<div class="article-title"><a href="/2024/06/08/%E5%AD%97%E8%8A%82%E7%A0%81%E4%B9%A6%E7%B1%8D%E7%BA%BF%E8%B7%AF/" title="书籍推荐">字节码学习线路</a></div>
		</h3>
	


		     
<div class="entry">

  <div class="row">
	
	
		<h3 id="这是什么语言？"><a href="#这是什么语言？" class="headerlink" title="这是什么语言？"></a>这是什么语言？</h3><p>你看到的 <code>push ebp</code>, <code>mov ebp, esp</code> 等内容，属于 <strong>x86 汇编语言 (Assembly Language)</strong>。</p>
<ul>
<li><strong>汇编语言</strong>：它不是一种单一的语言，而是一族与特定计算机体系结构（CPU架构）紧密相关的低级编程语言。我们这里讨论的 x86 汇编，是为 Intel 和 AMD 等公司生产的 x86 架构 CPU 设计的“母语”。</li>
<li><strong>为什么是“低级”语言？</strong>：因为它与机器指令（CPU能直接执行的二进制代码）几乎是一一对应的。<code>mov</code>, <code>push</code>, <code>pop</code> 这些助记符，最终都会被翻译成特定的二进制数字（机器码）让CPU执行。</li>
<li><strong>与高级语言的关系</strong>：像 Java, C++, Python 这样的高级语言，最终都必须通过<strong>编译器 (Compiler)</strong> 或 <strong>解释器 (Interpreter) + 即时编译器 (JIT)</strong>，被翻译成汇编语言，然后再转成机器码，才能在CPU上运行。</li>
</ul>
<p>你之前问到的 JVM 锁升级、JIT 编译等，其最终在操作系统和硬件层面执行的，就是这些汇编指令。</p>
<hr>
<h3 id="需要学习什么书籍才能懂这些？"><a href="#需要学习什么书籍才能懂这些？" class="headerlink" title="需要学习什么书籍才能懂这些？"></a>需要学习什么书籍才能懂这些？</h3><p>懂了这些，就能真正理解“代码是如何运行的”。这需要一个系统性的学习路径，而不是只看一本书。推荐一个从基础到深入的学习路径和经典书籍。</p>
<h4 id="学习路径"><a href="#学习路径" class="headerlink" title="学习路径"></a>学习路径</h4><ol>
<li><strong>第一步：打好地基 —— 计算机组成原理 (Computer Organization)</strong><br>在学习汇编之前，你必须先知道计算机的基本构造：什么是CPU，什么是内存，什么是寄存器（EBP&#x2F;ESP就是寄存器），数据是如何在它们之间流动的。</li>
<li><strong>第二步：理解环境 —— 操作系统 (Operating Systems)</strong><br>程序不是在真空中运行的。操作系统负责管理进程、线程、内存（虚拟内存）、文件系统等。函数调用、栈的建立，都离不开操作系统的支持。</li>
<li><strong>第三步：学习语言本身 —— 汇编语言 (Assembly Language)</strong><br>掌握汇编指令、寻址模式、伪指令，并开始编写简单的汇编程序。</li>
<li><strong>第四步：连接高低 —— 编译原理 (Compilers)</strong><br>理解高级语言的结构（如 <code>if</code> 语句, <code>for</code> 循环, 函数调用）是如何被翻译成汇编语言的。这是将你已有的 Java&#x2F;C++ 知识与汇编知识连接起来的关键。</li>
</ol>
<h4 id="经典书籍推荐"><a href="#经典书籍推荐" class="headerlink" title="经典书籍推荐"></a>经典书籍推荐</h4>
	
	</div>
  <a type="button" href="/2024/06/08/%E5%AD%97%E8%8A%82%E7%A0%81%E4%B9%A6%E7%B1%8D%E7%BA%BF%E8%B7%AF/#more" class="btn btn-default more">Read More</a>
</div>

	       
		     
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2024-02-04 </div>
			<div class="article-title"><a href="/2024/02/04/zgc/" title="ZGC">ZGC 介绍</a></div>
		</h3>
	


		     
<div class="entry">

  <div class="row">
	
	
		<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>ZGC 于 2017 由 Oracle 贡献给社区，在 JDK 11 及以上版本的各种 release 中几乎都包含该 GC。</p>
<p><a target="_blank" rel="noopener" href="https://wiki.openjdk.org/display/shenandoah/Main">Shenandoah</a> 是 Red Hat 主导的另一个低延迟的 GC，也承诺 pause time 低于 10ms，这两个项目目前处于竞争状态。该 GC 在 Oracle JDK 中不存在，但是在其他几个主流厂商的 JDK 中都包含，具体内容请参考项目主页。</p>
<h3 id="ZGC-的-“Z”-代表什么？"><a href="#ZGC-的-“Z”-代表什么？" class="headerlink" title="ZGC 的 “Z” 代表什么？"></a>ZGC 的 “Z” 代表什么？</h3><p>ZGC 只是一个名字，<strong>Z</strong> 不代表任何含义，不要把它理解为最后一代 GC，随着大家的探索，技术总是存在更优解。</p>
<p>It doesn’t stand for anything, ZGC is just a name. It was originally inspired by, or a homage to, ZFS (the filesystem) which in many ways was revolutionary when it first came out. Originally, ZFS was an acronym for “Zettabyte File System”, but that meaning was abandoned and it was later said to not stand for anything. It’s just a name. See <a target="_blank" rel="noopener" href="https://web.archive.org/web/20170223222515/https://blogs.oracle.com/bonwick/en_US/entry/you_say_zeta_i_say">Jeff Bonwick’s Blog</a> for more details.</p>
<h3 id="ZGC-的读法，”zed-gee-see”-or-“zee-gee-see”"><a href="#ZGC-的读法，”zed-gee-see”-or-“zee-gee-see”" class="headerlink" title="ZGC 的读法，”zed gee see” or “zee gee see”?"></a>ZGC 的读法，”zed gee see” or “zee gee see”?</h3><p>怎么读都行，无所谓。</p>
<p>There’s no preferred pronunciation, both are fine.</p>
<h2 id="ZGC-简单介绍"><a href="#ZGC-简单介绍" class="headerlink" title="ZGC 简单介绍"></a>ZGC 简单介绍</h2>
	
	</div>
  <a type="button" href="/2024/02/04/zgc/#more" class="btn btn-default more">Read More</a>
</div>

	       
		     
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2022-06-08 </div>
			<div class="article-title"><a href="/2022/06/08/spring-ioc/" title="Spring启动">Spring IOC 容器源码分析</a></div>
		</h3>
	


		     
<div class="entry">

  <div class="row">
	
	
		<p>Spring 最重要的概念是 IOC 和 AOP，本篇文章其实就是要来分析下 Spring 的 IOC 容器。既然平时都要用到 Spring，怎么可以不好好了解 Spring 呢？阅读本文并不能让成为 Spring 专家，不过一定有助于理解 Spring 的很多概念，帮助排查应用中和 Spring 相关的一些问题。</p>
<p>本文采用的源码版本是 4.3.11.RELEASE，算是 5.0.x 前比较新的版本了。为了降低难度，本文所说的所有的内容都是基于 xml 的配置的方式，实际使用已经很少人这么做了，至少不是纯 xml 配置，不过从理解源码的角度来看用这种方式来说无疑是最合适的。</p>
<p>阅读建议：至少需要知道怎么配置 Spring，了解 Spring 中的各种概念，少部分内容假设我使用过 SpringMVC。本文要说的 IOC 总体来说有两处地方最重要，一个是创建 Bean 容器，一个是初始化 Bean，如果自己觉得一次性看完本文压力有点大，那么可以按这个思路分两次消化。不一定对 Spring 容器的源码感兴趣，也许附录部分介绍的知识对读者有些许作用。</p>
<p>希望通过本文可以让自己不惧怕阅读 Spring 源码，也希望能反馈表述错误或不合理的地方。</p>
<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>先看下最基本的启动 Spring 容器的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;classpath:applicationfile.xml&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码就可以利用配置文件来启动一个 Spring 容器了，请使用 maven 的小伙伴直接在 dependencies 中加上以下依赖即可，个人比较反对那些不知道要添加什么依赖，然后把 Spring 的所有相关的东西都加进来的方式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;spring-context&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;<span class="number">4.3</span><span class="number">.11</span>.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>spring-context 会自动将 spring-core、spring-beans、spring-aop、spring-expression 这几个基础 jar 包带进来。</p>
</blockquote>
	
	</div>
  <a type="button" href="/2022/06/08/spring-ioc/#more" class="btn btn-default more">Read More</a>
</div>

	       
		     
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2022-03-04 </div>
			<div class="article-title"><a href="/2022/03/04/v2ray_x509_error/" title="Cloudflare v2ray一直 509 certificate signed by unknown authority">509 certificate signed by unknown authority</a></div>
		</h3>
	


		     
<div class="entry">

  <div class="row">
	
	
		<p>“x509: certificate signed by unknown authority” 错误表明 Nginx 或 V2Ray 客户端在验证 Cloudflare 源服务器证书（Origin Server Certificate）时，无法信任该证书的颁发机构（CA）。这通常是因为证书配置不正确、Cloudflare 的 SSL&#x2F;TLS 设置有误，或者缺少必要的根证书&#x2F;中间证书。本回答将针对你的 Cloudflare + V2Ray 配置（基于 WebSocket + TLS），提供详细的排查和解决步骤，帮助你修复这个错误。</p>
<h3 id="错误原因分析"><a href="#错误原因分析" class="headerlink" title="错误原因分析"></a><strong>错误原因分析</strong></h3><p>在 Cloudflare + V2Ray 的场景中，“certificate signed by unknown authority” 错误可能由以下原因引起：</p>
<ol>
<li><strong>源服务器证书未正确配置</strong>：Cloudflare 源服务器证书未正确安装到 Nginx，或文件内容有误。</li>
<li><strong>SSL&#x2F;TLS 模式问题</strong>：Cloudflare 的 SSL&#x2F;TLS 模式设置为 <strong>Full (strict)</strong>，但 VPS 未使用 Cloudflare 签发的证书，或者证书链不完整。</li>
<li><strong>缺少 Cloudflare 根证书</strong>：如果启用了 <strong>Authenticated Origin Pulls</strong>，Nginx 需要 Cloudflare 的根证书来验证边缘服务器的客户端证书。</li>
<li><strong>客户端配置错误</strong>：V2Ray 客户端的 TLS 设置（如 SNI）与服务器证书不匹配。</li>
<li><strong>证书和私钥不匹配</strong>：Nginx 使用的证书和私钥不对应，导致 TLS 握手失败。</li>
</ol>
<hr>
<h3 id="修复步骤"><a href="#修复步骤" class="headerlink" title="修复步骤"></a><strong>修复步骤</strong></h3><p>以下是针对 Cloudflare + V2Ray 配置的逐步排查和解决方法，假设你的 VPS 使用 Nginx 和 V2Ray，域名是 <code>v2ray.example.com</code>。</p>
<h4 id="步骤-1：检查-Nginx-错误日志"><a href="#步骤-1：检查-Nginx-错误日志" class="headerlink" title="步骤 1：检查 Nginx 错误日志"></a><strong>步骤 1：检查 Nginx 错误日志</strong></h4><ol>
<li>查看 Nginx 错误日志，获取详细错误信息：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /var/log/nginx/error.log</span><br></pre></td></tr></table></figure></li>
<li>查找类似以下的错误：<ul>
<li><code>x509: certificate signed by unknown authority</code></li>
<li><code>SSL: error:0B080074:x509 certificate routines</code></li>
</ul>
</li>
<li>记录具体错误上下文（例如错误发生在 TLS 握手还是客户端验证阶段）。</li>
</ol>
<h4 id="步骤-2：验证-Cloudflare-源服务器证书"><a href="#步骤-2：验证-Cloudflare-源服务器证书" class="headerlink" title="步骤 2：验证 Cloudflare 源服务器证书"></a><strong>步骤 2：验证 Cloudflare 源服务器证书</strong></h4>
	
	</div>
  <a type="button" href="/2022/03/04/v2ray_x509_error/#more" class="btn btn-default more">Read More</a>
</div>

	       
		     
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2021-06-14 </div>
			<div class="article-title"><a href="/2021/06/14/Threads-And-Locks-md/" title="Threads-And-Locks">深入分析 java 8 编程语言规范：Threads and Locks</a></div>
		</h3>
	


		     
<div class="entry">

  <div class="row">
	
	
		<p>在 java 并发编程中，线程和锁永远是最重要的概念。语言规范虽然是规范描述，但是其中也有非常多的知识和最佳实践是值得学习的，相信这篇文章还是可以给很多读者提供学习参考的。</p>
<p>本文主要是<strong>翻译 + 解释</strong> Oracle《<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/index.html">The Java Language Specification, Java SE 8 Edition</a>》的第17章《<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-17.html">Threads and Locks</a>》，原文大概30页pdf，我加入了很多自己的理解，希望能帮大家把规范看懂，并且从中得到很多你一直想要知道但是还不知道的知识。</p>
<p>注意，本文在说 Java 语言规范，不是 JVM 规范，JVM 的实现需要满足语言规范中定义的内容，但是具体的实现细节由各 JVM 厂商自己来决定。所以，语言规范要尽可能严谨全面，但是也不能限制过多，不然会限制 JVM 厂商对很多细节进行性能优化。</p>
<p>我能力有限，虽然已经很用心了，但有些地方我真的不懂，我已经在文中标记出来了。</p>
<p>建议分 3 部分阅读。</p>
<ol>
<li>将 17.1、17.2、17.3 一起阅读，这里关于线程中的 wait、notify、中断有很多的知识；</li>
<li>17.4 的内存模型比较长，重排序和 happens-before 关系是重点；</li>
<li>剩下的 final、字分裂、double和long的非原子问题，这些都是相对独立的 topic。</li>
</ol>
<div style="text-align: center; font-size: 24px; font-weight: bold">Chapter 17. Threads and Locks</div>

<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在 java 中，线程由 Thread 类表示，用户创建线程的<strong>唯一方式</strong>是创建 Thread 类的一个实例，每一个线程都和这样的一个实例关联。在相应的 Thread 实例上调用 start() 方法将启动一个线程。</p>
<p>如果没有正确使用同步，线程表现出来的现象将会是令人疑惑的、违反直觉的。这个章节将描述多线程编程的语义问题，包括一系列的规则，这些规则定义了<strong>在多线程环境中线程对共享内存中值的修改是否对其他线程立即可见</strong>。java编程语言内存模型定义了统一的内存模型用于屏蔽不同的硬件架构，在没有歧义的情况下，下面将用<strong>内存模型</strong>表示这个概念。</p>
	
	</div>
  <a type="button" href="/2021/06/14/Threads-And-Locks-md/#more" class="btn btn-default more">Read More</a>
</div>

	       
		     
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2021-06-14 </div>
			<div class="article-title"><a href="/2021/06/14/tx-fat%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/" title="分布式事务框架">tx-fat</a></div>
		</h3>
	


		     
<div class="entry">

  <div class="row">
	
	
		<h2 id="tx-fat-分布式事务框架面试介绍指南"><a href="#tx-fat-分布式事务框架面试介绍指南" class="headerlink" title="tx-fat 分布式事务框架面试介绍指南"></a>tx-fat 分布式事务框架面试介绍指南</h2><p>面试官您好，我参与&#x2F;负责的 <code>tx-fat</code> 项目是一个轻量级的分布式事务解决方案，主要目标是为微服务架构下的应用提供<strong>最终一致性</strong>的事务保障。</p>
<h3 id="一、项目背景与痛点-Why-We-Built-It"><a href="#一、项目背景与痛点-Why-We-Built-It" class="headerlink" title="一、项目背景与痛点 (Why We Built It)"></a>一、项目背景与痛点 (Why We Built It)</h3><ul>
<li><strong>为什么需要这个项目？</strong><ul>
<li>在微服务架构下，一个完整的业务操作往往需要跨越多个独立部署的服务。传统的单体应用中的本地数据库事务（ACID）无法保证这种跨服务操作的原子性——要么所有服务的操作都成功，要么都失败。</li>
<li><strong>举个例子</strong>：比如电商场景的下单操作，可能涉及到订单服务创建订单、库存服务扣减库存、积分服务增加积分。如果其中任何一个服务操作失败，我们希望整个下单流程都能回滚，避免数据不一致（比如订单创建了但库存没扣）。</li>
<li>传统的强一致性分布式事务方案，比如基于 XA 协议的两阶段提交（2PC），虽然能保证强一致性，但通常<strong>性能开销较大、实现复杂、对数据库和业务的侵入性也比较强</strong>，在高并发的互联网场景下可能不太适用。</li>
<li>因此，我们希望找到一种<strong>更轻量、对业务侵入更小、性能表现更好</strong>的解决方案，即使它牺牲了一点点的实时一致性，转而追求最终一致性。这就是我们开发 <code>tx-fat</code> 的初衷。</li>
</ul>
</li>
</ul>
<h3 id="二、项目目标-What-We-Aimed-For"><a href="#二、项目目标-What-We-Aimed-For" class="headerlink" title="二、项目目标 (What We Aimed For)"></a>二、项目目标 (What We Aimed For)</h3><ul>
<li><strong>我们想通过这个项目达到什么效果？</strong><ol>
<li><strong>易用性与低侵入性</strong>：开发者可以通过简单的注解（比如 <code>@FatTransaction</code>）就能将普通方法接入分布式事务管理，而不需要修改大量的业务代码。</li>
<li><strong>最终一致性保障</strong>：在分布式环境下，保证参与事务的各个服务最终能够达到一致的状态，要么全部成功提交，要么全部成功回滚各自的操作。</li>
<li><strong>主流RPC框架支持</strong>：能够与业界主流的微服务通信框架（如 Dubbo、Spring Cloud OpenFeign）无缝集成，自动完成事务上下文的跨服务传播。</li>
<li><strong>清晰的协调机制</strong>：提供明确的事务提交和回滚协调流程，并通过外部协调服务（我们选择了Redis）来管理事务状态。</li>
<li><strong>相对较好的性能</strong>：相比传统的2PC方案，我们希望通过异步协调和优化的流程来获得更好的性能和吞吐量。</li>
</ol>
</li>
</ul>
<h3 id="三、技术选型与核心架构-How-It-Works-Overview"><a href="#三、技术选型与核心架构-How-It-Works-Overview" class="headerlink" title="三、技术选型与核心架构 (How It Works - Overview)"></a>三、技术选型与核心架构 (How It Works - Overview)</h3><ul>
<li><strong>项目的整体设计思路和用了哪些关键技术？</strong><ul>
<li><strong>核心思想</strong>：<code>tx-fat</code> 的核心思想借鉴了类似两阶段提交（2PC）的模式，但我们将其改造为一种<strong>基于最终一致性的异步协调模型</strong>。可以理解为，我们有一个“协调员”（事务发起者），它会先让所有“参与者”（其他微服务）尝试执行自己的那部分任务，并告诉协调员“我准备好了，可以提交”，或者“我出错了，大家一起回滚吧”。</li>
<li><strong>协调中心 - Redis</strong>：<ul>
<li>我们选择 <strong>Redis</strong> 作为中心化的事务协调器和状态存储服务。</li>
<li><em>为什么是Redis？</em> 因为 Redis 具备高性能的内存读写能力，支持丰富的数据结构（如 Set、List、String），并且可以方便地实现分布式锁、状态标记等原子操作，非常适合做这种轻量级的协调工作。</li>
</ul>
</li>
<li><strong>事务管理与切入 - Spring AOP</strong>：<ul>
<li>我们利用 <strong>Spring AOP（面向切面编程）</strong> 的能力，通过自定义注解（如 <code>@FatTransaction</code> 标记事务方法，<code>@FatServiceRegister</code> 注册服务的提交&#x2F;回滚能力）来实现对事务的声明式管理。</li>
<li>这意味着业务代码只需要关注业务逻辑，事务的开启、提交、回滚等横切关注点由框架通过AOP自动织入。</li>
</ul>
</li>
<li><strong>事务上下文传播 - RPC拦截器&#x2F;过滤器</strong>：<ul>
<li>当一个服务调用链中包含多个微服务时，事务的相关信息（比如全局事务ID、当前分支ID等，我们称之为“事务上下文”）需要在这些服务间传递。</li>
<li><code>tx-fat</code> 提供了对 Dubbo（通过 Filter）和 Spring Cloud OpenFeign（通过 RequestInterceptor 和 HandlerInterceptor）的集成，自动在RPC调用时传递这些上下文信息。</li>
</ul>
</li>
<li><strong>一致性模型 - 最终一致性</strong>：<ul>
<li>我们追求的是<strong>最终一致性</strong>。这意味着在事务执行过程中，系统可能会存在短暂的数据不一致状态（比如A服务成功了，B服务还在处理中）。但框架会努力确保，经过协调后，所有服务的数据最终会达到一致（要么都提交，要么都回滚到初始状态）。这通常涉及到<strong>补偿逻辑</strong>（即回滚操作）。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="四、核心功能与实现细节-How-It-Works-Key-Details"><a href="#四、核心功能与实现细节-How-It-Works-Key-Details" class="headerlink" title="四、核心功能与实现细节 (How It Works - Key Details)"></a>四、核心功能与实现细节 (How It Works - Key Details)</h3><ul>
<li><strong>“能具体讲讲几个关键功能的实现吗？”</strong> （这部分是面试官最可能深入追问的，你需要对代码细节有把握）<ol>
<li><strong>服务注册机制 (<code>@FatServiceRegister</code>, <code>ServiceRegisterAspect</code>)</strong>：<ul>
<li>“每个参与事务的服务都需要告诉框架，如果事务要提交，它应该执行哪个方法；如果事务要回滚，它又应该执行哪个补偿方法。这是怎么做到的？”</li>
<li>开发者在服务实现类上使用 <code>@FatServiceRegister</code> 注解，指定服务名、提交方法名和回滚方法名。</li>
<li>应用启动时，<code>ServiceRegisterAspect</code> 会扫描这些注解，并通过 <code>ServiceRegisterResolver</code> 将这些元数据（服务名 -&gt; {提交方法, 回滚方法} 的映射）存储到 Redis 的一个特定 Key 中（比如 <code>SERVICE_SET:&#123;serviceName&#125;</code>）。这样，事务协调时就能动态查找到并调用它们。</li>
</ul>
</li>
<li><strong>事务的生命周期：发起、参与、协调</strong>：<ul>
<li><strong>事务发起 (<code>@FatTransaction</code>, <code>TransactionAspect</code>)</strong>：<ul>
<li>当一个被 <code>@FatTransaction</code> 注解的方法首次被调用（或者注解显式指定 <code>isStart=true</code>），并且当前线程没有事务上下文时，它就成为<strong>事务发起者</strong>。</li>
<li><code>TransactionAspect</code> 会拦截这个方法调用，生成一个全局唯一的事务组ID（<code>groupKey</code>）和当前分支ID（<code>currentKey</code>），并将这些信息封装在 <code>TransactionContent</code> 对象中，存入 <code>TransactionThreadLocal</code>，这样在同一个线程内就能共享这个事务信息。</li>
<li>同时，发起者会将自己（服务名）注册到 Redis 的一个代表当前事务组的集合中（比如 <code>GROUP_SERVICE_SET:&#123;groupKey&#125;</code>），表明它参与了这个全局事务。</li>
</ul>
</li>
<li><strong>事务参与 (RPC拦截与上下文传递)</strong>：<ul>
<li>当发起者或其他已参与者通过RPC调用下游服务时，框架提供的RPC拦截器（如 <code>FatDubboFilter</code>）会从 <code>TransactionThreadLocal</code> 中获取 <code>TransactionContent</code>，将其序列化（通常是JSON），并附加到RPC请求中（比如Dubbo的Attachment或HTTP Header）。</li>
<li>下游服务的RPC拦截器接收到请求后，会解析出这个事务上下文，并将其设置到自己线程的 <code>TransactionThreadLocal</code> 中。这样，下游服务就知道自己是某个全局事务的<strong>参与者</strong>了。它也会将自己的服务名注册到上述的 <code>GROUP_SERVICE_SET:&#123;groupKey&#125;</code>。</li>
</ul>
</li>
<li><strong>事务提交协调 (<code>CommitResolver.commitTransaction()</code>)</strong>：<ul>
<li>“如果发起者的业务逻辑成功了，怎么确保所有参与者都一起提交呢？”</li>
<li>发起者会调用 <code>CommitResolver</code>。这个协调器会做几件事：<ol>
<li><strong>检查全局回滚标记</strong>：首先看 Redis 中是否有针对此 <code>groupKey</code> 的“一票否决”回滚标记（比如 <code>BLOCK_MARK:&#123;groupKey&#125;</code>）。如果有，说明已经有其他分支出错了，直接转入回滚。</li>
<li><strong>等待所有参与者就绪</strong>：发起者会等待（通过轮询 Redis 的特定 Key，比如 <code>SERVICE_READY_COMMIT_LIST:&#123;groupKey&#125;</code> 和 <code>GROUP_CAN_COMMIT_LIST:&#123;groupKey&#125;</code>，并设有超时机制）所有在 <code>GROUP_SERVICE_SET:&#123;groupKey&#125;</code> 中注册的参与者都声明自己“本地业务已完成，可以提交”。</li>
<li><strong>执行最终提交</strong>：如果所有参与者都确认可以提交，并且没有错误和超时，协调者就会通知所有参与者执行它们之前注册的 <code>commit</code> 方法（通过 <code>ServiceRunningHandler</code> 反射调用）。</li>
<li><strong>清理状态</strong>：提交完成后，清理 Redis 中与此事务相关的所有临时状态数据。</li>
</ol>
</li>
</ul>
</li>
<li><strong>事务回滚协调 (<code>CommitResolver.rollbackTransaction()</code>)</strong>：<ul>
<li>“如果任何一个环节出错了，如何保证所有操作都撤销呢？”</li>
<li>回滚可能由多种情况触发：发起者业务异常、参与者业务异常（通过在 Redis 中设置错误标记 <code>SERVICE_ERROR_MARK:&#123;groupKey&#125;:&#123;branchKey&#125;</code> 被协调者发现）、提交或等待超时等。</li>
<li>一旦决定回滚，协调者会：<ol>
<li><strong>设置全局回滚标记</strong>：立即在 Redis 中设置 <code>BLOCK_MARK:&#123;groupKey&#125;</code>，阻止任何其他分支尝试提交。</li>
<li><strong>执行补偿操作</strong>：通知所有已参与的服务执行它们注册的 <code>rollback</code> 方法（补偿方法）。</li>
<li><strong>清理状态</strong>：回滚完成后，同样清理 Redis 中的事务状态数据。</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>Redis Key 的设计与运用</strong>：<ul>
<li>“你们在 Redis 中用了哪些关键的 Key 来管理事务状态？”</li>
<li>可以重点介绍几个，比如：<ul>
<li><code>SERVICE_SET:&#123;serviceName&#125;</code>: 存储服务注册的提议&#x2F;回滚方法。</li>
<li><code>GROUP_SERVICE_SET:&#123;groupKey&#125;</code>: 记录参与当前事务的所有服务。</li>
<li><code>BLOCK_MARK:&#123;groupKey&#125;</code>: 全局回滚标记。</li>
<li><code>SERVICE_ERROR_MARK:&#123;groupKey&#125;:&#123;branchKey&#125;</code>: 特定分支错误标记。</li>
<li><code>SERVICE_READY_COMMIT_LIST:&#123;groupKey&#125;</code> &#x2F; <code>GROUP_CAN_COMMIT_LIST:&#123;groupKey&#125;</code>: 用于协调提交阶段各方状态的列表。</li>
<li>并说明这些 Key 通常都会设置<strong>过期时间（TTL）</strong>，以防止异常情况下数据永久残留。</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ul>
	
	</div>
  <a type="button" href="/2021/06/14/tx-fat%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/#more" class="btn btn-default more">Read More</a>
</div>

	       
		     
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2021-03-26 </div>
			<div class="article-title"><a href="/2021/03/26/netty-1/" title="Netty 解析">Netty 源码解析（一）</a></div>
		</h3>
	


		     
<div class="entry">

  <div class="row">
	
	
		<p>本文又是一篇源码分析文章，其实除了 Doug Lea 的并发包源码，我是真不太爱写源码分析。因为要花非常多的时间，而且很多地方需要反复组织语言。</p>
<p>本文将介绍 Netty，Java 平台上使用最广泛的 NIO 包，它是对 JDK 中的 NIO 实现的一层封装，让我们能更方便地开发 NIO 程序。其实，Netty 不仅仅是 NIO 吧，但是，基本上大家都冲着 NIO 来的。</p>
<p>个人感觉国内对于 Netty 的吹嘘是有点过了，主要是很多人靠它吃饭，要么是搞培训的，要么是出书的，恨不得把 Netty 吹上天去，这种现象也是挺不好的，反而使得初学者觉得 Netty 是什么高深的技术一样。</p>
<p>Netty 的源码不是很简单，因为它比较多，而且各个类之间的关系错综复杂，很多人说它的源码很好，这点我觉得一般，真要说好代码，还得 Doug Lea 的并发源码比较漂亮，一行行都是精华，不过它们是不同类型的，也没什么好对比的。Netty 源码好就好在它的接口使用比较灵活，往往接口好用的框架，源码都不会太简单。</p>
<p>本文将立足于源码分析，所以读者需要先掌握 NIO 的基础知识，至少我之前写的 <a href="/post/java-nio">《Java NIO：Buffer、Channel 和 Selector》</a> 中介绍的基础知识要清楚，如果读者已经对 Netty 有些了解，或者使用过，那就更好了。</p>
<ul>
<li>本文只介绍 TCP 相关的内容，Netty 对于其他协议的支持，不在本文的讨论范围内。</li>
<li>和并发包的源码分析不一样，我不可能一行一行源码说，所以有些异常分支是会直接略过，除非我觉得需要介绍。</li>
<li>Netty 源码一直在更新，各版本之间有些差异，我是按照 2018-09-06 的最新版本 <strong>4.1.25.Final</strong> 来进行介绍的。</li>
</ul>
<p>建议初学者在看完本文以后，可以去翻翻《Netty In Action》，网上也可以找到中文文字版的。</p>
<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>学习源码，一开始肯定是准备环境。</p>
<p>我喜欢用 maven，也喜欢 Spring Boot，所以我一般先到 <a target="_blank" rel="noopener" href="https://start.spring.io/">https://start.spring.io/</a> 准备一个最简单的脚手架。</p>
	
	</div>
  <a type="button" href="/2021/03/26/netty-1/#more" class="btn btn-default more">Read More</a>
</div>

	       
	     </div>
	     <div>
	       <center>
	         <div class="pagination">
<ul class="pagination">
	 
		
          <li class="prev disabled"><a><i class="fa fa-arrow-circle-o-left"></i>Prev</a></li>
        

        <li><a href="/"><i class="fa fa-home"></i>Home</a></li>

		
		   <li class="next"> <a href="/tags/wiki/page/2/" class="alignright next">Next<i class="fa fa-arrow-circle-o-right"></i></a> </li>
        
	
</ul>
</div>

	       </center>
	     </div>	
      

</div> <!-- col-md-9/col-md-12 -->


<div class="col-md-3">
	<div id="sidebar">
	
			
  <div id="site_search">
   <div class="form-group">
    <input type="text" id="local-search-input" name="q" results="0" placeholder="Search" class="st-search-input st-default-search-input form-control"/>
   </div>  
  <div id="local-search-result"></div>
  </div>


		
			<div class="widget">
    
</div>

		
			
	<div class="widget">
		<h4>Categories</h4>
		<ul class="tag_box inline list-unstyled">
		
			<li><a href="/categories/Hexo/">Hexo<span>1</span></a></li>
		
			<li><a href="/categories/Java/">Java<span>3</span></a></li>
		
			<li><a href="/categories/Spring/Java/">Java<span>1</span></a></li>
		
			<li><a href="/categories/ShardingSphere/">ShardingSphere<span>1</span></a></li>
		
			<li><a href="/categories/Spring/">Spring<span>2</span></a></li>
		
			<li><a href="/categories/blog/">blog<span>1</span></a></li>
		
			<li><a href="/categories/v2ray/cloudflare/">cloudflare<span>1</span></a></li>
		
			<li><a href="/categories/%E4%BA%8B%E5%8A%A1/fat/">fat<span>1</span></a></li>
		
			<li><a href="/categories/llm/">llm<span>2</span></a></li>
		
			<li><a href="/categories/netty/">netty<span>1</span></a></li>
		
			<li><a href="/categories/llm/pdf/">pdf<span>1</span></a></li>
		
			<li><a href="/categories/v2ray/">v2ray<span>1</span></a></li>
		
			<li><a href="/categories/%E4%BA%8B%E5%8A%A1/">事务<span>1</span></a></li>
		
			<li><a href="/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程<span>10</span></a></li>
		
			<li><a href="/categories/%E7%9B%91%E6%8E%A7/">监控<span>1</span></a></li>
		
		</ul>
	</div>

		
			
	<div class="widget">
		<h4>Tag Cloud</h4>
		<ul class="tag_box inline list-unstyled">		
		
			<li><a href="/tags/llm/">llm<span>1</span></a></li>
		
			<li><a href="/tags/wiki/">wiki<span>22</span></a></li>
		
			<li><a href="/tags/aop/">aop<span>1</span></a></li>
		
			<li><a href="/tags/spring/">spring<span>1</span></a></li>
		
			<li><a href="/tags/pdf/">pdf<span>1</span></a></li>
		
		 
		</ul>
	</div>


		
			
<div class="widget">
  <h4>Recent Posts</h4>
  <ul class="entry list-unstyled">
    
      <li>
        <a href="/2025/05/13/pdf2zn/"  title="pdf翻译" ><i class="fa fa-file-o"></i>nebius</a>
      </li>
    
      <li>
        <a href="/2025/03/11/llm-agent-java/"  title="基于springboot开发agent" ><i class="fa fa-file-o"></i>llm-agent工具开发</a>
      </li>
    
      <li>
        <a href="/2024/10/09/prometheus-grafana/"  title="Prometheus、Grafana " ><i class="fa fa-file-o"></i>Prometheus 数据类型解析与 Grafana 制图</a>
      </li>
    
      <li>
        <a href="/2024/09/01/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/"  title="Sharding分库分表实践、主从读取" ><i class="fa fa-file-o"></i>Sharding分库分表实践</a>
      </li>
    
      <li>
        <a href="/2024/06/08/%E5%AD%97%E8%8A%82%E7%A0%81%E4%B9%A6%E7%B1%8D%E7%BA%BF%E8%B7%AF/"  title="书籍推荐" ><i class="fa fa-file-o"></i>字节码学习线路</a>
      </li>
    
  </ul>
</div>

		
	</div> <!-- sidebar -->
</div> <!-- col-md-3 -->




    </div>
  </div>
  <div class="container-narrow">
    <footer> <p>
  &copy; 2025 shineXGO
  
      with help from <a href="http://hexo.io/" target="_blank">Hexo</a> and <a href="http://getbootstrap.com/" target="_blank">Twitter Bootstrap</a>. Theme by <a target="_blank" rel="noopener" href="http://github.com/wzpan/hexo-theme-freemind/">Freemind</a>.    
</p> </footer>
  </div> <!-- container-narrow -->
  


  
<a id="gotop" href="#">   
  <span>▲</span> 
</a>

<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/bootstrap.min.js"></script>
<script src="/js/main.js"></script>
<script src="/js/search.js"></script> 


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>



   <script type="text/javascript">      
     var search_path = "search.xml";
	 if (search_path.length == 0) {
	 	search_path = "search.xml";
	 }
	 var path = "/" + search_path;
     searchFunc(path, 'local-search-input', 'local-search-result');
   </script>


<!-- syntax highlighting -->


</body>
</html>